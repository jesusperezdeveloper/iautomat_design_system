// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'timeline_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$DSTimelineConfig {
  DSTimelineVariant get variant => throw _privateConstructorUsedError;
  DSTimelineState get state => throw _privateConstructorUsedError;
  List<DSTimelineEvent> get events => throw _privateConstructorUsedError;
  DSTimelineOrientation get orientation => throw _privateConstructorUsedError;
  DSTimelineConnectorStyle get connectorStyle =>
      throw _privateConstructorUsedError;
  DSTimelineIndicatorStyle get indicatorStyle =>
      throw _privateConstructorUsedError;
  DSTimelineAlignment get alignment => throw _privateConstructorUsedError;
  DSTimelineSpacing get spacing => throw _privateConstructorUsedError;
  Color? get connectorColor => throw _privateConstructorUsedError;
  Color? get indicatorColor => throw _privateConstructorUsedError;
  Color? get backgroundColor => throw _privateConstructorUsedError;
  Color? get foregroundColor => throw _privateConstructorUsedError;
  double? get connectorWidth => throw _privateConstructorUsedError;
  double? get indicatorSize => throw _privateConstructorUsedError;
  double? get itemSpacing => throw _privateConstructorUsedError;
  EdgeInsetsGeometry? get padding => throw _privateConstructorUsedError;
  EdgeInsetsGeometry? get margin => throw _privateConstructorUsedError;
  DSTimelineStyle? get style => throw _privateConstructorUsedError;
  DSTimelineInteraction? get interaction => throw _privateConstructorUsedError;
  DSTimelineAccessibility? get accessibility =>
      throw _privateConstructorUsedError;
  DSTimelineAnimation? get animation => throw _privateConstructorUsedError;
  ValueChanged<int>? get onEventTap => throw _privateConstructorUsedError;
  ValueChanged<int>? get onEventLongPress => throw _privateConstructorUsedError;
  ValueChanged<int>? get onEventHover => throw _privateConstructorUsedError;
  VoidCallback? get onTap => throw _privateConstructorUsedError;
  VoidCallback? get onLongPress => throw _privateConstructorUsedError;
  VoidCallback? get onHover => throw _privateConstructorUsedError;
  String? get semanticLabel => throw _privateConstructorUsedError;
  String? get tooltip => throw _privateConstructorUsedError;
  bool get enabled => throw _privateConstructorUsedError;
  bool get loading => throw _privateConstructorUsedError;
  bool get skeleton => throw _privateConstructorUsedError;
  bool get visible => throw _privateConstructorUsedError;
  bool get interactive => throw _privateConstructorUsedError;
  bool get scrollable => throw _privateConstructorUsedError;
  bool get reversed => throw _privateConstructorUsedError;
  bool get shrinkWrap => throw _privateConstructorUsedError;
  int? get selectedIndex => throw _privateConstructorUsedError;
  ScrollController? get scrollController => throw _privateConstructorUsedError;

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DSTimelineConfigCopyWith<DSTimelineConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DSTimelineConfigCopyWith<$Res> {
  factory $DSTimelineConfigCopyWith(
    DSTimelineConfig value,
    $Res Function(DSTimelineConfig) then,
  ) = _$DSTimelineConfigCopyWithImpl<$Res, DSTimelineConfig>;
  @useResult
  $Res call({
    DSTimelineVariant variant,
    DSTimelineState state,
    List<DSTimelineEvent> events,
    DSTimelineOrientation orientation,
    DSTimelineConnectorStyle connectorStyle,
    DSTimelineIndicatorStyle indicatorStyle,
    DSTimelineAlignment alignment,
    DSTimelineSpacing spacing,
    Color? connectorColor,
    Color? indicatorColor,
    Color? backgroundColor,
    Color? foregroundColor,
    double? connectorWidth,
    double? indicatorSize,
    double? itemSpacing,
    EdgeInsetsGeometry? padding,
    EdgeInsetsGeometry? margin,
    DSTimelineStyle? style,
    DSTimelineInteraction? interaction,
    DSTimelineAccessibility? accessibility,
    DSTimelineAnimation? animation,
    ValueChanged<int>? onEventTap,
    ValueChanged<int>? onEventLongPress,
    ValueChanged<int>? onEventHover,
    VoidCallback? onTap,
    VoidCallback? onLongPress,
    VoidCallback? onHover,
    String? semanticLabel,
    String? tooltip,
    bool enabled,
    bool loading,
    bool skeleton,
    bool visible,
    bool interactive,
    bool scrollable,
    bool reversed,
    bool shrinkWrap,
    int? selectedIndex,
    ScrollController? scrollController,
  });

  $DSTimelineStyleCopyWith<$Res>? get style;
  $DSTimelineInteractionCopyWith<$Res>? get interaction;
  $DSTimelineAccessibilityCopyWith<$Res>? get accessibility;
  $DSTimelineAnimationCopyWith<$Res>? get animation;
}

/// @nodoc
class _$DSTimelineConfigCopyWithImpl<$Res, $Val extends DSTimelineConfig>
    implements $DSTimelineConfigCopyWith<$Res> {
  _$DSTimelineConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? variant = null,
    Object? state = null,
    Object? events = null,
    Object? orientation = null,
    Object? connectorStyle = null,
    Object? indicatorStyle = null,
    Object? alignment = null,
    Object? spacing = null,
    Object? connectorColor = freezed,
    Object? indicatorColor = freezed,
    Object? backgroundColor = freezed,
    Object? foregroundColor = freezed,
    Object? connectorWidth = freezed,
    Object? indicatorSize = freezed,
    Object? itemSpacing = freezed,
    Object? padding = freezed,
    Object? margin = freezed,
    Object? style = freezed,
    Object? interaction = freezed,
    Object? accessibility = freezed,
    Object? animation = freezed,
    Object? onEventTap = freezed,
    Object? onEventLongPress = freezed,
    Object? onEventHover = freezed,
    Object? onTap = freezed,
    Object? onLongPress = freezed,
    Object? onHover = freezed,
    Object? semanticLabel = freezed,
    Object? tooltip = freezed,
    Object? enabled = null,
    Object? loading = null,
    Object? skeleton = null,
    Object? visible = null,
    Object? interactive = null,
    Object? scrollable = null,
    Object? reversed = null,
    Object? shrinkWrap = null,
    Object? selectedIndex = freezed,
    Object? scrollController = freezed,
  }) {
    return _then(
      _value.copyWith(
            variant: null == variant
                ? _value.variant
                : variant // ignore: cast_nullable_to_non_nullable
                      as DSTimelineVariant,
            state: null == state
                ? _value.state
                : state // ignore: cast_nullable_to_non_nullable
                      as DSTimelineState,
            events: null == events
                ? _value.events
                : events // ignore: cast_nullable_to_non_nullable
                      as List<DSTimelineEvent>,
            orientation: null == orientation
                ? _value.orientation
                : orientation // ignore: cast_nullable_to_non_nullable
                      as DSTimelineOrientation,
            connectorStyle: null == connectorStyle
                ? _value.connectorStyle
                : connectorStyle // ignore: cast_nullable_to_non_nullable
                      as DSTimelineConnectorStyle,
            indicatorStyle: null == indicatorStyle
                ? _value.indicatorStyle
                : indicatorStyle // ignore: cast_nullable_to_non_nullable
                      as DSTimelineIndicatorStyle,
            alignment: null == alignment
                ? _value.alignment
                : alignment // ignore: cast_nullable_to_non_nullable
                      as DSTimelineAlignment,
            spacing: null == spacing
                ? _value.spacing
                : spacing // ignore: cast_nullable_to_non_nullable
                      as DSTimelineSpacing,
            connectorColor: freezed == connectorColor
                ? _value.connectorColor
                : connectorColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            indicatorColor: freezed == indicatorColor
                ? _value.indicatorColor
                : indicatorColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            backgroundColor: freezed == backgroundColor
                ? _value.backgroundColor
                : backgroundColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            foregroundColor: freezed == foregroundColor
                ? _value.foregroundColor
                : foregroundColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            connectorWidth: freezed == connectorWidth
                ? _value.connectorWidth
                : connectorWidth // ignore: cast_nullable_to_non_nullable
                      as double?,
            indicatorSize: freezed == indicatorSize
                ? _value.indicatorSize
                : indicatorSize // ignore: cast_nullable_to_non_nullable
                      as double?,
            itemSpacing: freezed == itemSpacing
                ? _value.itemSpacing
                : itemSpacing // ignore: cast_nullable_to_non_nullable
                      as double?,
            padding: freezed == padding
                ? _value.padding
                : padding // ignore: cast_nullable_to_non_nullable
                      as EdgeInsetsGeometry?,
            margin: freezed == margin
                ? _value.margin
                : margin // ignore: cast_nullable_to_non_nullable
                      as EdgeInsetsGeometry?,
            style: freezed == style
                ? _value.style
                : style // ignore: cast_nullable_to_non_nullable
                      as DSTimelineStyle?,
            interaction: freezed == interaction
                ? _value.interaction
                : interaction // ignore: cast_nullable_to_non_nullable
                      as DSTimelineInteraction?,
            accessibility: freezed == accessibility
                ? _value.accessibility
                : accessibility // ignore: cast_nullable_to_non_nullable
                      as DSTimelineAccessibility?,
            animation: freezed == animation
                ? _value.animation
                : animation // ignore: cast_nullable_to_non_nullable
                      as DSTimelineAnimation?,
            onEventTap: freezed == onEventTap
                ? _value.onEventTap
                : onEventTap // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<int>?,
            onEventLongPress: freezed == onEventLongPress
                ? _value.onEventLongPress
                : onEventLongPress // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<int>?,
            onEventHover: freezed == onEventHover
                ? _value.onEventHover
                : onEventHover // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<int>?,
            onTap: freezed == onTap
                ? _value.onTap
                : onTap // ignore: cast_nullable_to_non_nullable
                      as VoidCallback?,
            onLongPress: freezed == onLongPress
                ? _value.onLongPress
                : onLongPress // ignore: cast_nullable_to_non_nullable
                      as VoidCallback?,
            onHover: freezed == onHover
                ? _value.onHover
                : onHover // ignore: cast_nullable_to_non_nullable
                      as VoidCallback?,
            semanticLabel: freezed == semanticLabel
                ? _value.semanticLabel
                : semanticLabel // ignore: cast_nullable_to_non_nullable
                      as String?,
            tooltip: freezed == tooltip
                ? _value.tooltip
                : tooltip // ignore: cast_nullable_to_non_nullable
                      as String?,
            enabled: null == enabled
                ? _value.enabled
                : enabled // ignore: cast_nullable_to_non_nullable
                      as bool,
            loading: null == loading
                ? _value.loading
                : loading // ignore: cast_nullable_to_non_nullable
                      as bool,
            skeleton: null == skeleton
                ? _value.skeleton
                : skeleton // ignore: cast_nullable_to_non_nullable
                      as bool,
            visible: null == visible
                ? _value.visible
                : visible // ignore: cast_nullable_to_non_nullable
                      as bool,
            interactive: null == interactive
                ? _value.interactive
                : interactive // ignore: cast_nullable_to_non_nullable
                      as bool,
            scrollable: null == scrollable
                ? _value.scrollable
                : scrollable // ignore: cast_nullable_to_non_nullable
                      as bool,
            reversed: null == reversed
                ? _value.reversed
                : reversed // ignore: cast_nullable_to_non_nullable
                      as bool,
            shrinkWrap: null == shrinkWrap
                ? _value.shrinkWrap
                : shrinkWrap // ignore: cast_nullable_to_non_nullable
                      as bool,
            selectedIndex: freezed == selectedIndex
                ? _value.selectedIndex
                : selectedIndex // ignore: cast_nullable_to_non_nullable
                      as int?,
            scrollController: freezed == scrollController
                ? _value.scrollController
                : scrollController // ignore: cast_nullable_to_non_nullable
                      as ScrollController?,
          )
          as $Val,
    );
  }

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DSTimelineStyleCopyWith<$Res>? get style {
    if (_value.style == null) {
      return null;
    }

    return $DSTimelineStyleCopyWith<$Res>(_value.style!, (value) {
      return _then(_value.copyWith(style: value) as $Val);
    });
  }

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DSTimelineInteractionCopyWith<$Res>? get interaction {
    if (_value.interaction == null) {
      return null;
    }

    return $DSTimelineInteractionCopyWith<$Res>(_value.interaction!, (value) {
      return _then(_value.copyWith(interaction: value) as $Val);
    });
  }

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DSTimelineAccessibilityCopyWith<$Res>? get accessibility {
    if (_value.accessibility == null) {
      return null;
    }

    return $DSTimelineAccessibilityCopyWith<$Res>(_value.accessibility!, (
      value,
    ) {
      return _then(_value.copyWith(accessibility: value) as $Val);
    });
  }

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DSTimelineAnimationCopyWith<$Res>? get animation {
    if (_value.animation == null) {
      return null;
    }

    return $DSTimelineAnimationCopyWith<$Res>(_value.animation!, (value) {
      return _then(_value.copyWith(animation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DSTimelineConfigImplCopyWith<$Res>
    implements $DSTimelineConfigCopyWith<$Res> {
  factory _$$DSTimelineConfigImplCopyWith(
    _$DSTimelineConfigImpl value,
    $Res Function(_$DSTimelineConfigImpl) then,
  ) = __$$DSTimelineConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    DSTimelineVariant variant,
    DSTimelineState state,
    List<DSTimelineEvent> events,
    DSTimelineOrientation orientation,
    DSTimelineConnectorStyle connectorStyle,
    DSTimelineIndicatorStyle indicatorStyle,
    DSTimelineAlignment alignment,
    DSTimelineSpacing spacing,
    Color? connectorColor,
    Color? indicatorColor,
    Color? backgroundColor,
    Color? foregroundColor,
    double? connectorWidth,
    double? indicatorSize,
    double? itemSpacing,
    EdgeInsetsGeometry? padding,
    EdgeInsetsGeometry? margin,
    DSTimelineStyle? style,
    DSTimelineInteraction? interaction,
    DSTimelineAccessibility? accessibility,
    DSTimelineAnimation? animation,
    ValueChanged<int>? onEventTap,
    ValueChanged<int>? onEventLongPress,
    ValueChanged<int>? onEventHover,
    VoidCallback? onTap,
    VoidCallback? onLongPress,
    VoidCallback? onHover,
    String? semanticLabel,
    String? tooltip,
    bool enabled,
    bool loading,
    bool skeleton,
    bool visible,
    bool interactive,
    bool scrollable,
    bool reversed,
    bool shrinkWrap,
    int? selectedIndex,
    ScrollController? scrollController,
  });

  @override
  $DSTimelineStyleCopyWith<$Res>? get style;
  @override
  $DSTimelineInteractionCopyWith<$Res>? get interaction;
  @override
  $DSTimelineAccessibilityCopyWith<$Res>? get accessibility;
  @override
  $DSTimelineAnimationCopyWith<$Res>? get animation;
}

/// @nodoc
class __$$DSTimelineConfigImplCopyWithImpl<$Res>
    extends _$DSTimelineConfigCopyWithImpl<$Res, _$DSTimelineConfigImpl>
    implements _$$DSTimelineConfigImplCopyWith<$Res> {
  __$$DSTimelineConfigImplCopyWithImpl(
    _$DSTimelineConfigImpl _value,
    $Res Function(_$DSTimelineConfigImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? variant = null,
    Object? state = null,
    Object? events = null,
    Object? orientation = null,
    Object? connectorStyle = null,
    Object? indicatorStyle = null,
    Object? alignment = null,
    Object? spacing = null,
    Object? connectorColor = freezed,
    Object? indicatorColor = freezed,
    Object? backgroundColor = freezed,
    Object? foregroundColor = freezed,
    Object? connectorWidth = freezed,
    Object? indicatorSize = freezed,
    Object? itemSpacing = freezed,
    Object? padding = freezed,
    Object? margin = freezed,
    Object? style = freezed,
    Object? interaction = freezed,
    Object? accessibility = freezed,
    Object? animation = freezed,
    Object? onEventTap = freezed,
    Object? onEventLongPress = freezed,
    Object? onEventHover = freezed,
    Object? onTap = freezed,
    Object? onLongPress = freezed,
    Object? onHover = freezed,
    Object? semanticLabel = freezed,
    Object? tooltip = freezed,
    Object? enabled = null,
    Object? loading = null,
    Object? skeleton = null,
    Object? visible = null,
    Object? interactive = null,
    Object? scrollable = null,
    Object? reversed = null,
    Object? shrinkWrap = null,
    Object? selectedIndex = freezed,
    Object? scrollController = freezed,
  }) {
    return _then(
      _$DSTimelineConfigImpl(
        variant: null == variant
            ? _value.variant
            : variant // ignore: cast_nullable_to_non_nullable
                  as DSTimelineVariant,
        state: null == state
            ? _value.state
            : state // ignore: cast_nullable_to_non_nullable
                  as DSTimelineState,
        events: null == events
            ? _value._events
            : events // ignore: cast_nullable_to_non_nullable
                  as List<DSTimelineEvent>,
        orientation: null == orientation
            ? _value.orientation
            : orientation // ignore: cast_nullable_to_non_nullable
                  as DSTimelineOrientation,
        connectorStyle: null == connectorStyle
            ? _value.connectorStyle
            : connectorStyle // ignore: cast_nullable_to_non_nullable
                  as DSTimelineConnectorStyle,
        indicatorStyle: null == indicatorStyle
            ? _value.indicatorStyle
            : indicatorStyle // ignore: cast_nullable_to_non_nullable
                  as DSTimelineIndicatorStyle,
        alignment: null == alignment
            ? _value.alignment
            : alignment // ignore: cast_nullable_to_non_nullable
                  as DSTimelineAlignment,
        spacing: null == spacing
            ? _value.spacing
            : spacing // ignore: cast_nullable_to_non_nullable
                  as DSTimelineSpacing,
        connectorColor: freezed == connectorColor
            ? _value.connectorColor
            : connectorColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        indicatorColor: freezed == indicatorColor
            ? _value.indicatorColor
            : indicatorColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        backgroundColor: freezed == backgroundColor
            ? _value.backgroundColor
            : backgroundColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        foregroundColor: freezed == foregroundColor
            ? _value.foregroundColor
            : foregroundColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        connectorWidth: freezed == connectorWidth
            ? _value.connectorWidth
            : connectorWidth // ignore: cast_nullable_to_non_nullable
                  as double?,
        indicatorSize: freezed == indicatorSize
            ? _value.indicatorSize
            : indicatorSize // ignore: cast_nullable_to_non_nullable
                  as double?,
        itemSpacing: freezed == itemSpacing
            ? _value.itemSpacing
            : itemSpacing // ignore: cast_nullable_to_non_nullable
                  as double?,
        padding: freezed == padding
            ? _value.padding
            : padding // ignore: cast_nullable_to_non_nullable
                  as EdgeInsetsGeometry?,
        margin: freezed == margin
            ? _value.margin
            : margin // ignore: cast_nullable_to_non_nullable
                  as EdgeInsetsGeometry?,
        style: freezed == style
            ? _value.style
            : style // ignore: cast_nullable_to_non_nullable
                  as DSTimelineStyle?,
        interaction: freezed == interaction
            ? _value.interaction
            : interaction // ignore: cast_nullable_to_non_nullable
                  as DSTimelineInteraction?,
        accessibility: freezed == accessibility
            ? _value.accessibility
            : accessibility // ignore: cast_nullable_to_non_nullable
                  as DSTimelineAccessibility?,
        animation: freezed == animation
            ? _value.animation
            : animation // ignore: cast_nullable_to_non_nullable
                  as DSTimelineAnimation?,
        onEventTap: freezed == onEventTap
            ? _value.onEventTap
            : onEventTap // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<int>?,
        onEventLongPress: freezed == onEventLongPress
            ? _value.onEventLongPress
            : onEventLongPress // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<int>?,
        onEventHover: freezed == onEventHover
            ? _value.onEventHover
            : onEventHover // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<int>?,
        onTap: freezed == onTap
            ? _value.onTap
            : onTap // ignore: cast_nullable_to_non_nullable
                  as VoidCallback?,
        onLongPress: freezed == onLongPress
            ? _value.onLongPress
            : onLongPress // ignore: cast_nullable_to_non_nullable
                  as VoidCallback?,
        onHover: freezed == onHover
            ? _value.onHover
            : onHover // ignore: cast_nullable_to_non_nullable
                  as VoidCallback?,
        semanticLabel: freezed == semanticLabel
            ? _value.semanticLabel
            : semanticLabel // ignore: cast_nullable_to_non_nullable
                  as String?,
        tooltip: freezed == tooltip
            ? _value.tooltip
            : tooltip // ignore: cast_nullable_to_non_nullable
                  as String?,
        enabled: null == enabled
            ? _value.enabled
            : enabled // ignore: cast_nullable_to_non_nullable
                  as bool,
        loading: null == loading
            ? _value.loading
            : loading // ignore: cast_nullable_to_non_nullable
                  as bool,
        skeleton: null == skeleton
            ? _value.skeleton
            : skeleton // ignore: cast_nullable_to_non_nullable
                  as bool,
        visible: null == visible
            ? _value.visible
            : visible // ignore: cast_nullable_to_non_nullable
                  as bool,
        interactive: null == interactive
            ? _value.interactive
            : interactive // ignore: cast_nullable_to_non_nullable
                  as bool,
        scrollable: null == scrollable
            ? _value.scrollable
            : scrollable // ignore: cast_nullable_to_non_nullable
                  as bool,
        reversed: null == reversed
            ? _value.reversed
            : reversed // ignore: cast_nullable_to_non_nullable
                  as bool,
        shrinkWrap: null == shrinkWrap
            ? _value.shrinkWrap
            : shrinkWrap // ignore: cast_nullable_to_non_nullable
                  as bool,
        selectedIndex: freezed == selectedIndex
            ? _value.selectedIndex
            : selectedIndex // ignore: cast_nullable_to_non_nullable
                  as int?,
        scrollController: freezed == scrollController
            ? _value.scrollController
            : scrollController // ignore: cast_nullable_to_non_nullable
                  as ScrollController?,
      ),
    );
  }
}

/// @nodoc

class _$DSTimelineConfigImpl extends _DSTimelineConfig {
  const _$DSTimelineConfigImpl({
    this.variant = DSTimelineVariant.activity,
    this.state = DSTimelineState.defaultState,
    final List<DSTimelineEvent> events = const <DSTimelineEvent>[],
    this.orientation = DSTimelineOrientation.vertical,
    this.connectorStyle = DSTimelineConnectorStyle.solid,
    this.indicatorStyle = DSTimelineIndicatorStyle.dot,
    this.alignment = DSTimelineAlignment.start,
    this.spacing = DSTimelineSpacing.medium,
    this.connectorColor,
    this.indicatorColor,
    this.backgroundColor,
    this.foregroundColor,
    this.connectorWidth,
    this.indicatorSize,
    this.itemSpacing,
    this.padding,
    this.margin,
    this.style,
    this.interaction,
    this.accessibility,
    this.animation,
    this.onEventTap,
    this.onEventLongPress,
    this.onEventHover,
    this.onTap,
    this.onLongPress,
    this.onHover,
    this.semanticLabel,
    this.tooltip,
    this.enabled = true,
    this.loading = false,
    this.skeleton = false,
    this.visible = true,
    this.interactive = false,
    this.scrollable = false,
    this.reversed = false,
    this.shrinkWrap = false,
    this.selectedIndex,
    this.scrollController,
  }) : _events = events,
       super._();

  @override
  @JsonKey()
  final DSTimelineVariant variant;
  @override
  @JsonKey()
  final DSTimelineState state;
  final List<DSTimelineEvent> _events;
  @override
  @JsonKey()
  List<DSTimelineEvent> get events {
    if (_events is EqualUnmodifiableListView) return _events;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_events);
  }

  @override
  @JsonKey()
  final DSTimelineOrientation orientation;
  @override
  @JsonKey()
  final DSTimelineConnectorStyle connectorStyle;
  @override
  @JsonKey()
  final DSTimelineIndicatorStyle indicatorStyle;
  @override
  @JsonKey()
  final DSTimelineAlignment alignment;
  @override
  @JsonKey()
  final DSTimelineSpacing spacing;
  @override
  final Color? connectorColor;
  @override
  final Color? indicatorColor;
  @override
  final Color? backgroundColor;
  @override
  final Color? foregroundColor;
  @override
  final double? connectorWidth;
  @override
  final double? indicatorSize;
  @override
  final double? itemSpacing;
  @override
  final EdgeInsetsGeometry? padding;
  @override
  final EdgeInsetsGeometry? margin;
  @override
  final DSTimelineStyle? style;
  @override
  final DSTimelineInteraction? interaction;
  @override
  final DSTimelineAccessibility? accessibility;
  @override
  final DSTimelineAnimation? animation;
  @override
  final ValueChanged<int>? onEventTap;
  @override
  final ValueChanged<int>? onEventLongPress;
  @override
  final ValueChanged<int>? onEventHover;
  @override
  final VoidCallback? onTap;
  @override
  final VoidCallback? onLongPress;
  @override
  final VoidCallback? onHover;
  @override
  final String? semanticLabel;
  @override
  final String? tooltip;
  @override
  @JsonKey()
  final bool enabled;
  @override
  @JsonKey()
  final bool loading;
  @override
  @JsonKey()
  final bool skeleton;
  @override
  @JsonKey()
  final bool visible;
  @override
  @JsonKey()
  final bool interactive;
  @override
  @JsonKey()
  final bool scrollable;
  @override
  @JsonKey()
  final bool reversed;
  @override
  @JsonKey()
  final bool shrinkWrap;
  @override
  final int? selectedIndex;
  @override
  final ScrollController? scrollController;

  @override
  String toString() {
    return 'DSTimelineConfig(variant: $variant, state: $state, events: $events, orientation: $orientation, connectorStyle: $connectorStyle, indicatorStyle: $indicatorStyle, alignment: $alignment, spacing: $spacing, connectorColor: $connectorColor, indicatorColor: $indicatorColor, backgroundColor: $backgroundColor, foregroundColor: $foregroundColor, connectorWidth: $connectorWidth, indicatorSize: $indicatorSize, itemSpacing: $itemSpacing, padding: $padding, margin: $margin, style: $style, interaction: $interaction, accessibility: $accessibility, animation: $animation, onEventTap: $onEventTap, onEventLongPress: $onEventLongPress, onEventHover: $onEventHover, onTap: $onTap, onLongPress: $onLongPress, onHover: $onHover, semanticLabel: $semanticLabel, tooltip: $tooltip, enabled: $enabled, loading: $loading, skeleton: $skeleton, visible: $visible, interactive: $interactive, scrollable: $scrollable, reversed: $reversed, shrinkWrap: $shrinkWrap, selectedIndex: $selectedIndex, scrollController: $scrollController)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DSTimelineConfigImpl &&
            (identical(other.variant, variant) || other.variant == variant) &&
            (identical(other.state, state) || other.state == state) &&
            const DeepCollectionEquality().equals(other._events, _events) &&
            (identical(other.orientation, orientation) ||
                other.orientation == orientation) &&
            (identical(other.connectorStyle, connectorStyle) ||
                other.connectorStyle == connectorStyle) &&
            (identical(other.indicatorStyle, indicatorStyle) ||
                other.indicatorStyle == indicatorStyle) &&
            (identical(other.alignment, alignment) ||
                other.alignment == alignment) &&
            (identical(other.spacing, spacing) || other.spacing == spacing) &&
            (identical(other.connectorColor, connectorColor) ||
                other.connectorColor == connectorColor) &&
            (identical(other.indicatorColor, indicatorColor) ||
                other.indicatorColor == indicatorColor) &&
            (identical(other.backgroundColor, backgroundColor) ||
                other.backgroundColor == backgroundColor) &&
            (identical(other.foregroundColor, foregroundColor) ||
                other.foregroundColor == foregroundColor) &&
            (identical(other.connectorWidth, connectorWidth) ||
                other.connectorWidth == connectorWidth) &&
            (identical(other.indicatorSize, indicatorSize) ||
                other.indicatorSize == indicatorSize) &&
            (identical(other.itemSpacing, itemSpacing) ||
                other.itemSpacing == itemSpacing) &&
            (identical(other.padding, padding) || other.padding == padding) &&
            (identical(other.margin, margin) || other.margin == margin) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.interaction, interaction) ||
                other.interaction == interaction) &&
            (identical(other.accessibility, accessibility) ||
                other.accessibility == accessibility) &&
            (identical(other.animation, animation) ||
                other.animation == animation) &&
            (identical(other.onEventTap, onEventTap) ||
                other.onEventTap == onEventTap) &&
            (identical(other.onEventLongPress, onEventLongPress) ||
                other.onEventLongPress == onEventLongPress) &&
            (identical(other.onEventHover, onEventHover) ||
                other.onEventHover == onEventHover) &&
            (identical(other.onTap, onTap) || other.onTap == onTap) &&
            (identical(other.onLongPress, onLongPress) ||
                other.onLongPress == onLongPress) &&
            (identical(other.onHover, onHover) || other.onHover == onHover) &&
            (identical(other.semanticLabel, semanticLabel) ||
                other.semanticLabel == semanticLabel) &&
            (identical(other.tooltip, tooltip) || other.tooltip == tooltip) &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.loading, loading) || other.loading == loading) &&
            (identical(other.skeleton, skeleton) ||
                other.skeleton == skeleton) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.interactive, interactive) ||
                other.interactive == interactive) &&
            (identical(other.scrollable, scrollable) ||
                other.scrollable == scrollable) &&
            (identical(other.reversed, reversed) ||
                other.reversed == reversed) &&
            (identical(other.shrinkWrap, shrinkWrap) ||
                other.shrinkWrap == shrinkWrap) &&
            (identical(other.selectedIndex, selectedIndex) ||
                other.selectedIndex == selectedIndex) &&
            (identical(other.scrollController, scrollController) ||
                other.scrollController == scrollController));
  }

  @override
  int get hashCode => Object.hashAll([
    runtimeType,
    variant,
    state,
    const DeepCollectionEquality().hash(_events),
    orientation,
    connectorStyle,
    indicatorStyle,
    alignment,
    spacing,
    connectorColor,
    indicatorColor,
    backgroundColor,
    foregroundColor,
    connectorWidth,
    indicatorSize,
    itemSpacing,
    padding,
    margin,
    style,
    interaction,
    accessibility,
    animation,
    onEventTap,
    onEventLongPress,
    onEventHover,
    onTap,
    onLongPress,
    onHover,
    semanticLabel,
    tooltip,
    enabled,
    loading,
    skeleton,
    visible,
    interactive,
    scrollable,
    reversed,
    shrinkWrap,
    selectedIndex,
    scrollController,
  ]);

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DSTimelineConfigImplCopyWith<_$DSTimelineConfigImpl> get copyWith =>
      __$$DSTimelineConfigImplCopyWithImpl<_$DSTimelineConfigImpl>(
        this,
        _$identity,
      );
}

abstract class _DSTimelineConfig extends DSTimelineConfig {
  const factory _DSTimelineConfig({
    final DSTimelineVariant variant,
    final DSTimelineState state,
    final List<DSTimelineEvent> events,
    final DSTimelineOrientation orientation,
    final DSTimelineConnectorStyle connectorStyle,
    final DSTimelineIndicatorStyle indicatorStyle,
    final DSTimelineAlignment alignment,
    final DSTimelineSpacing spacing,
    final Color? connectorColor,
    final Color? indicatorColor,
    final Color? backgroundColor,
    final Color? foregroundColor,
    final double? connectorWidth,
    final double? indicatorSize,
    final double? itemSpacing,
    final EdgeInsetsGeometry? padding,
    final EdgeInsetsGeometry? margin,
    final DSTimelineStyle? style,
    final DSTimelineInteraction? interaction,
    final DSTimelineAccessibility? accessibility,
    final DSTimelineAnimation? animation,
    final ValueChanged<int>? onEventTap,
    final ValueChanged<int>? onEventLongPress,
    final ValueChanged<int>? onEventHover,
    final VoidCallback? onTap,
    final VoidCallback? onLongPress,
    final VoidCallback? onHover,
    final String? semanticLabel,
    final String? tooltip,
    final bool enabled,
    final bool loading,
    final bool skeleton,
    final bool visible,
    final bool interactive,
    final bool scrollable,
    final bool reversed,
    final bool shrinkWrap,
    final int? selectedIndex,
    final ScrollController? scrollController,
  }) = _$DSTimelineConfigImpl;
  const _DSTimelineConfig._() : super._();

  @override
  DSTimelineVariant get variant;
  @override
  DSTimelineState get state;
  @override
  List<DSTimelineEvent> get events;
  @override
  DSTimelineOrientation get orientation;
  @override
  DSTimelineConnectorStyle get connectorStyle;
  @override
  DSTimelineIndicatorStyle get indicatorStyle;
  @override
  DSTimelineAlignment get alignment;
  @override
  DSTimelineSpacing get spacing;
  @override
  Color? get connectorColor;
  @override
  Color? get indicatorColor;
  @override
  Color? get backgroundColor;
  @override
  Color? get foregroundColor;
  @override
  double? get connectorWidth;
  @override
  double? get indicatorSize;
  @override
  double? get itemSpacing;
  @override
  EdgeInsetsGeometry? get padding;
  @override
  EdgeInsetsGeometry? get margin;
  @override
  DSTimelineStyle? get style;
  @override
  DSTimelineInteraction? get interaction;
  @override
  DSTimelineAccessibility? get accessibility;
  @override
  DSTimelineAnimation? get animation;
  @override
  ValueChanged<int>? get onEventTap;
  @override
  ValueChanged<int>? get onEventLongPress;
  @override
  ValueChanged<int>? get onEventHover;
  @override
  VoidCallback? get onTap;
  @override
  VoidCallback? get onLongPress;
  @override
  VoidCallback? get onHover;
  @override
  String? get semanticLabel;
  @override
  String? get tooltip;
  @override
  bool get enabled;
  @override
  bool get loading;
  @override
  bool get skeleton;
  @override
  bool get visible;
  @override
  bool get interactive;
  @override
  bool get scrollable;
  @override
  bool get reversed;
  @override
  bool get shrinkWrap;
  @override
  int? get selectedIndex;
  @override
  ScrollController? get scrollController;

  /// Create a copy of DSTimelineConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DSTimelineConfigImplCopyWith<_$DSTimelineConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DSTimelineEvent {
  String get id => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get subtitle => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  DateTime? get timestamp => throw _privateConstructorUsedError;
  Widget? get content => throw _privateConstructorUsedError;
  Widget? get leading => throw _privateConstructorUsedError;
  Widget? get trailing => throw _privateConstructorUsedError;
  IconData? get icon => throw _privateConstructorUsedError;
  Color? get iconColor => throw _privateConstructorUsedError;
  Color? get backgroundColor => throw _privateConstructorUsedError;
  Color? get borderColor => throw _privateConstructorUsedError;
  String? get semanticLabel => throw _privateConstructorUsedError;
  DSTimelineEventType? get type => throw _privateConstructorUsedError;
  DSTimelineEventStatus? get status => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;
  VoidCallback? get onTap => throw _privateConstructorUsedError;
  VoidCallback? get onLongPress => throw _privateConstructorUsedError;
  VoidCallback? get onHover => throw _privateConstructorUsedError;
  bool get enabled => throw _privateConstructorUsedError;
  bool get visible => throw _privateConstructorUsedError;
  bool get selected => throw _privateConstructorUsedError;
  bool get highlighted => throw _privateConstructorUsedError;
  bool get isStart => throw _privateConstructorUsedError;
  bool get isEnd => throw _privateConstructorUsedError;

  /// Create a copy of DSTimelineEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DSTimelineEventCopyWith<DSTimelineEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DSTimelineEventCopyWith<$Res> {
  factory $DSTimelineEventCopyWith(
    DSTimelineEvent value,
    $Res Function(DSTimelineEvent) then,
  ) = _$DSTimelineEventCopyWithImpl<$Res, DSTimelineEvent>;
  @useResult
  $Res call({
    String id,
    String? title,
    String? subtitle,
    String? description,
    DateTime? timestamp,
    Widget? content,
    Widget? leading,
    Widget? trailing,
    IconData? icon,
    Color? iconColor,
    Color? backgroundColor,
    Color? borderColor,
    String? semanticLabel,
    DSTimelineEventType? type,
    DSTimelineEventStatus? status,
    Map<String, dynamic>? metadata,
    VoidCallback? onTap,
    VoidCallback? onLongPress,
    VoidCallback? onHover,
    bool enabled,
    bool visible,
    bool selected,
    bool highlighted,
    bool isStart,
    bool isEnd,
  });
}

/// @nodoc
class _$DSTimelineEventCopyWithImpl<$Res, $Val extends DSTimelineEvent>
    implements $DSTimelineEventCopyWith<$Res> {
  _$DSTimelineEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DSTimelineEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = freezed,
    Object? subtitle = freezed,
    Object? description = freezed,
    Object? timestamp = freezed,
    Object? content = freezed,
    Object? leading = freezed,
    Object? trailing = freezed,
    Object? icon = freezed,
    Object? iconColor = freezed,
    Object? backgroundColor = freezed,
    Object? borderColor = freezed,
    Object? semanticLabel = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? metadata = freezed,
    Object? onTap = freezed,
    Object? onLongPress = freezed,
    Object? onHover = freezed,
    Object? enabled = null,
    Object? visible = null,
    Object? selected = null,
    Object? highlighted = null,
    Object? isStart = null,
    Object? isEnd = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            title: freezed == title
                ? _value.title
                : title // ignore: cast_nullable_to_non_nullable
                      as String?,
            subtitle: freezed == subtitle
                ? _value.subtitle
                : subtitle // ignore: cast_nullable_to_non_nullable
                      as String?,
            description: freezed == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                      as String?,
            timestamp: freezed == timestamp
                ? _value.timestamp
                : timestamp // ignore: cast_nullable_to_non_nullable
                      as DateTime?,
            content: freezed == content
                ? _value.content
                : content // ignore: cast_nullable_to_non_nullable
                      as Widget?,
            leading: freezed == leading
                ? _value.leading
                : leading // ignore: cast_nullable_to_non_nullable
                      as Widget?,
            trailing: freezed == trailing
                ? _value.trailing
                : trailing // ignore: cast_nullable_to_non_nullable
                      as Widget?,
            icon: freezed == icon
                ? _value.icon
                : icon // ignore: cast_nullable_to_non_nullable
                      as IconData?,
            iconColor: freezed == iconColor
                ? _value.iconColor
                : iconColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            backgroundColor: freezed == backgroundColor
                ? _value.backgroundColor
                : backgroundColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            borderColor: freezed == borderColor
                ? _value.borderColor
                : borderColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            semanticLabel: freezed == semanticLabel
                ? _value.semanticLabel
                : semanticLabel // ignore: cast_nullable_to_non_nullable
                      as String?,
            type: freezed == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as DSTimelineEventType?,
            status: freezed == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as DSTimelineEventStatus?,
            metadata: freezed == metadata
                ? _value.metadata
                : metadata // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>?,
            onTap: freezed == onTap
                ? _value.onTap
                : onTap // ignore: cast_nullable_to_non_nullable
                      as VoidCallback?,
            onLongPress: freezed == onLongPress
                ? _value.onLongPress
                : onLongPress // ignore: cast_nullable_to_non_nullable
                      as VoidCallback?,
            onHover: freezed == onHover
                ? _value.onHover
                : onHover // ignore: cast_nullable_to_non_nullable
                      as VoidCallback?,
            enabled: null == enabled
                ? _value.enabled
                : enabled // ignore: cast_nullable_to_non_nullable
                      as bool,
            visible: null == visible
                ? _value.visible
                : visible // ignore: cast_nullable_to_non_nullable
                      as bool,
            selected: null == selected
                ? _value.selected
                : selected // ignore: cast_nullable_to_non_nullable
                      as bool,
            highlighted: null == highlighted
                ? _value.highlighted
                : highlighted // ignore: cast_nullable_to_non_nullable
                      as bool,
            isStart: null == isStart
                ? _value.isStart
                : isStart // ignore: cast_nullable_to_non_nullable
                      as bool,
            isEnd: null == isEnd
                ? _value.isEnd
                : isEnd // ignore: cast_nullable_to_non_nullable
                      as bool,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DSTimelineEventImplCopyWith<$Res>
    implements $DSTimelineEventCopyWith<$Res> {
  factory _$$DSTimelineEventImplCopyWith(
    _$DSTimelineEventImpl value,
    $Res Function(_$DSTimelineEventImpl) then,
  ) = __$$DSTimelineEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String? title,
    String? subtitle,
    String? description,
    DateTime? timestamp,
    Widget? content,
    Widget? leading,
    Widget? trailing,
    IconData? icon,
    Color? iconColor,
    Color? backgroundColor,
    Color? borderColor,
    String? semanticLabel,
    DSTimelineEventType? type,
    DSTimelineEventStatus? status,
    Map<String, dynamic>? metadata,
    VoidCallback? onTap,
    VoidCallback? onLongPress,
    VoidCallback? onHover,
    bool enabled,
    bool visible,
    bool selected,
    bool highlighted,
    bool isStart,
    bool isEnd,
  });
}

/// @nodoc
class __$$DSTimelineEventImplCopyWithImpl<$Res>
    extends _$DSTimelineEventCopyWithImpl<$Res, _$DSTimelineEventImpl>
    implements _$$DSTimelineEventImplCopyWith<$Res> {
  __$$DSTimelineEventImplCopyWithImpl(
    _$DSTimelineEventImpl _value,
    $Res Function(_$DSTimelineEventImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DSTimelineEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = freezed,
    Object? subtitle = freezed,
    Object? description = freezed,
    Object? timestamp = freezed,
    Object? content = freezed,
    Object? leading = freezed,
    Object? trailing = freezed,
    Object? icon = freezed,
    Object? iconColor = freezed,
    Object? backgroundColor = freezed,
    Object? borderColor = freezed,
    Object? semanticLabel = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? metadata = freezed,
    Object? onTap = freezed,
    Object? onLongPress = freezed,
    Object? onHover = freezed,
    Object? enabled = null,
    Object? visible = null,
    Object? selected = null,
    Object? highlighted = null,
    Object? isStart = null,
    Object? isEnd = null,
  }) {
    return _then(
      _$DSTimelineEventImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        title: freezed == title
            ? _value.title
            : title // ignore: cast_nullable_to_non_nullable
                  as String?,
        subtitle: freezed == subtitle
            ? _value.subtitle
            : subtitle // ignore: cast_nullable_to_non_nullable
                  as String?,
        description: freezed == description
            ? _value.description
            : description // ignore: cast_nullable_to_non_nullable
                  as String?,
        timestamp: freezed == timestamp
            ? _value.timestamp
            : timestamp // ignore: cast_nullable_to_non_nullable
                  as DateTime?,
        content: freezed == content
            ? _value.content
            : content // ignore: cast_nullable_to_non_nullable
                  as Widget?,
        leading: freezed == leading
            ? _value.leading
            : leading // ignore: cast_nullable_to_non_nullable
                  as Widget?,
        trailing: freezed == trailing
            ? _value.trailing
            : trailing // ignore: cast_nullable_to_non_nullable
                  as Widget?,
        icon: freezed == icon
            ? _value.icon
            : icon // ignore: cast_nullable_to_non_nullable
                  as IconData?,
        iconColor: freezed == iconColor
            ? _value.iconColor
            : iconColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        backgroundColor: freezed == backgroundColor
            ? _value.backgroundColor
            : backgroundColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        borderColor: freezed == borderColor
            ? _value.borderColor
            : borderColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        semanticLabel: freezed == semanticLabel
            ? _value.semanticLabel
            : semanticLabel // ignore: cast_nullable_to_non_nullable
                  as String?,
        type: freezed == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as DSTimelineEventType?,
        status: freezed == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as DSTimelineEventStatus?,
        metadata: freezed == metadata
            ? _value._metadata
            : metadata // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>?,
        onTap: freezed == onTap
            ? _value.onTap
            : onTap // ignore: cast_nullable_to_non_nullable
                  as VoidCallback?,
        onLongPress: freezed == onLongPress
            ? _value.onLongPress
            : onLongPress // ignore: cast_nullable_to_non_nullable
                  as VoidCallback?,
        onHover: freezed == onHover
            ? _value.onHover
            : onHover // ignore: cast_nullable_to_non_nullable
                  as VoidCallback?,
        enabled: null == enabled
            ? _value.enabled
            : enabled // ignore: cast_nullable_to_non_nullable
                  as bool,
        visible: null == visible
            ? _value.visible
            : visible // ignore: cast_nullable_to_non_nullable
                  as bool,
        selected: null == selected
            ? _value.selected
            : selected // ignore: cast_nullable_to_non_nullable
                  as bool,
        highlighted: null == highlighted
            ? _value.highlighted
            : highlighted // ignore: cast_nullable_to_non_nullable
                  as bool,
        isStart: null == isStart
            ? _value.isStart
            : isStart // ignore: cast_nullable_to_non_nullable
                  as bool,
        isEnd: null == isEnd
            ? _value.isEnd
            : isEnd // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }
}

/// @nodoc

class _$DSTimelineEventImpl extends _DSTimelineEvent {
  const _$DSTimelineEventImpl({
    required this.id,
    this.title,
    this.subtitle,
    this.description,
    this.timestamp,
    this.content,
    this.leading,
    this.trailing,
    this.icon,
    this.iconColor,
    this.backgroundColor,
    this.borderColor,
    this.semanticLabel,
    this.type,
    this.status,
    final Map<String, dynamic>? metadata,
    this.onTap,
    this.onLongPress,
    this.onHover,
    this.enabled = true,
    this.visible = true,
    this.selected = false,
    this.highlighted = false,
    this.isStart = false,
    this.isEnd = false,
  }) : _metadata = metadata,
       super._();

  @override
  final String id;
  @override
  final String? title;
  @override
  final String? subtitle;
  @override
  final String? description;
  @override
  final DateTime? timestamp;
  @override
  final Widget? content;
  @override
  final Widget? leading;
  @override
  final Widget? trailing;
  @override
  final IconData? icon;
  @override
  final Color? iconColor;
  @override
  final Color? backgroundColor;
  @override
  final Color? borderColor;
  @override
  final String? semanticLabel;
  @override
  final DSTimelineEventType? type;
  @override
  final DSTimelineEventStatus? status;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final VoidCallback? onTap;
  @override
  final VoidCallback? onLongPress;
  @override
  final VoidCallback? onHover;
  @override
  @JsonKey()
  final bool enabled;
  @override
  @JsonKey()
  final bool visible;
  @override
  @JsonKey()
  final bool selected;
  @override
  @JsonKey()
  final bool highlighted;
  @override
  @JsonKey()
  final bool isStart;
  @override
  @JsonKey()
  final bool isEnd;

  @override
  String toString() {
    return 'DSTimelineEvent(id: $id, title: $title, subtitle: $subtitle, description: $description, timestamp: $timestamp, content: $content, leading: $leading, trailing: $trailing, icon: $icon, iconColor: $iconColor, backgroundColor: $backgroundColor, borderColor: $borderColor, semanticLabel: $semanticLabel, type: $type, status: $status, metadata: $metadata, onTap: $onTap, onLongPress: $onLongPress, onHover: $onHover, enabled: $enabled, visible: $visible, selected: $selected, highlighted: $highlighted, isStart: $isStart, isEnd: $isEnd)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DSTimelineEventImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.subtitle, subtitle) ||
                other.subtitle == subtitle) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.leading, leading) || other.leading == leading) &&
            (identical(other.trailing, trailing) ||
                other.trailing == trailing) &&
            (identical(other.icon, icon) || other.icon == icon) &&
            (identical(other.iconColor, iconColor) ||
                other.iconColor == iconColor) &&
            (identical(other.backgroundColor, backgroundColor) ||
                other.backgroundColor == backgroundColor) &&
            (identical(other.borderColor, borderColor) ||
                other.borderColor == borderColor) &&
            (identical(other.semanticLabel, semanticLabel) ||
                other.semanticLabel == semanticLabel) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.onTap, onTap) || other.onTap == onTap) &&
            (identical(other.onLongPress, onLongPress) ||
                other.onLongPress == onLongPress) &&
            (identical(other.onHover, onHover) || other.onHover == onHover) &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.selected, selected) ||
                other.selected == selected) &&
            (identical(other.highlighted, highlighted) ||
                other.highlighted == highlighted) &&
            (identical(other.isStart, isStart) || other.isStart == isStart) &&
            (identical(other.isEnd, isEnd) || other.isEnd == isEnd));
  }

  @override
  int get hashCode => Object.hashAll([
    runtimeType,
    id,
    title,
    subtitle,
    description,
    timestamp,
    content,
    leading,
    trailing,
    icon,
    iconColor,
    backgroundColor,
    borderColor,
    semanticLabel,
    type,
    status,
    const DeepCollectionEquality().hash(_metadata),
    onTap,
    onLongPress,
    onHover,
    enabled,
    visible,
    selected,
    highlighted,
    isStart,
    isEnd,
  ]);

  /// Create a copy of DSTimelineEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DSTimelineEventImplCopyWith<_$DSTimelineEventImpl> get copyWith =>
      __$$DSTimelineEventImplCopyWithImpl<_$DSTimelineEventImpl>(
        this,
        _$identity,
      );
}

abstract class _DSTimelineEvent extends DSTimelineEvent {
  const factory _DSTimelineEvent({
    required final String id,
    final String? title,
    final String? subtitle,
    final String? description,
    final DateTime? timestamp,
    final Widget? content,
    final Widget? leading,
    final Widget? trailing,
    final IconData? icon,
    final Color? iconColor,
    final Color? backgroundColor,
    final Color? borderColor,
    final String? semanticLabel,
    final DSTimelineEventType? type,
    final DSTimelineEventStatus? status,
    final Map<String, dynamic>? metadata,
    final VoidCallback? onTap,
    final VoidCallback? onLongPress,
    final VoidCallback? onHover,
    final bool enabled,
    final bool visible,
    final bool selected,
    final bool highlighted,
    final bool isStart,
    final bool isEnd,
  }) = _$DSTimelineEventImpl;
  const _DSTimelineEvent._() : super._();

  @override
  String get id;
  @override
  String? get title;
  @override
  String? get subtitle;
  @override
  String? get description;
  @override
  DateTime? get timestamp;
  @override
  Widget? get content;
  @override
  Widget? get leading;
  @override
  Widget? get trailing;
  @override
  IconData? get icon;
  @override
  Color? get iconColor;
  @override
  Color? get backgroundColor;
  @override
  Color? get borderColor;
  @override
  String? get semanticLabel;
  @override
  DSTimelineEventType? get type;
  @override
  DSTimelineEventStatus? get status;
  @override
  Map<String, dynamic>? get metadata;
  @override
  VoidCallback? get onTap;
  @override
  VoidCallback? get onLongPress;
  @override
  VoidCallback? get onHover;
  @override
  bool get enabled;
  @override
  bool get visible;
  @override
  bool get selected;
  @override
  bool get highlighted;
  @override
  bool get isStart;
  @override
  bool get isEnd;

  /// Create a copy of DSTimelineEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DSTimelineEventImplCopyWith<_$DSTimelineEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DSTimelineStyle {
  Color? get backgroundColor => throw _privateConstructorUsedError;
  Color? get foregroundColor => throw _privateConstructorUsedError;
  Color? get connectorColor => throw _privateConstructorUsedError;
  Color? get indicatorColor => throw _privateConstructorUsedError;
  Color? get shadowColor => throw _privateConstructorUsedError;
  Color? get overlayColor => throw _privateConstructorUsedError;
  double? get connectorWidth => throw _privateConstructorUsedError;
  double? get indicatorSize => throw _privateConstructorUsedError;
  double? get itemSpacing => throw _privateConstructorUsedError;
  double? get borderRadius => throw _privateConstructorUsedError;
  double? get elevation => throw _privateConstructorUsedError;
  EdgeInsetsGeometry? get padding => throw _privateConstructorUsedError;
  EdgeInsetsGeometry? get margin => throw _privateConstructorUsedError;
  BoxConstraints? get constraints => throw _privateConstructorUsedError;
  Decoration? get decoration => throw _privateConstructorUsedError;
  TextStyle? get titleStyle => throw _privateConstructorUsedError;
  TextStyle? get subtitleStyle => throw _privateConstructorUsedError;
  TextStyle? get descriptionStyle => throw _privateConstructorUsedError;
  TextStyle? get timestampStyle => throw _privateConstructorUsedError;
  Offset? get offset => throw _privateConstructorUsedError;

  /// Create a copy of DSTimelineStyle
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DSTimelineStyleCopyWith<DSTimelineStyle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DSTimelineStyleCopyWith<$Res> {
  factory $DSTimelineStyleCopyWith(
    DSTimelineStyle value,
    $Res Function(DSTimelineStyle) then,
  ) = _$DSTimelineStyleCopyWithImpl<$Res, DSTimelineStyle>;
  @useResult
  $Res call({
    Color? backgroundColor,
    Color? foregroundColor,
    Color? connectorColor,
    Color? indicatorColor,
    Color? shadowColor,
    Color? overlayColor,
    double? connectorWidth,
    double? indicatorSize,
    double? itemSpacing,
    double? borderRadius,
    double? elevation,
    EdgeInsetsGeometry? padding,
    EdgeInsetsGeometry? margin,
    BoxConstraints? constraints,
    Decoration? decoration,
    TextStyle? titleStyle,
    TextStyle? subtitleStyle,
    TextStyle? descriptionStyle,
    TextStyle? timestampStyle,
    Offset? offset,
  });
}

/// @nodoc
class _$DSTimelineStyleCopyWithImpl<$Res, $Val extends DSTimelineStyle>
    implements $DSTimelineStyleCopyWith<$Res> {
  _$DSTimelineStyleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DSTimelineStyle
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? backgroundColor = freezed,
    Object? foregroundColor = freezed,
    Object? connectorColor = freezed,
    Object? indicatorColor = freezed,
    Object? shadowColor = freezed,
    Object? overlayColor = freezed,
    Object? connectorWidth = freezed,
    Object? indicatorSize = freezed,
    Object? itemSpacing = freezed,
    Object? borderRadius = freezed,
    Object? elevation = freezed,
    Object? padding = freezed,
    Object? margin = freezed,
    Object? constraints = freezed,
    Object? decoration = freezed,
    Object? titleStyle = freezed,
    Object? subtitleStyle = freezed,
    Object? descriptionStyle = freezed,
    Object? timestampStyle = freezed,
    Object? offset = freezed,
  }) {
    return _then(
      _value.copyWith(
            backgroundColor: freezed == backgroundColor
                ? _value.backgroundColor
                : backgroundColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            foregroundColor: freezed == foregroundColor
                ? _value.foregroundColor
                : foregroundColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            connectorColor: freezed == connectorColor
                ? _value.connectorColor
                : connectorColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            indicatorColor: freezed == indicatorColor
                ? _value.indicatorColor
                : indicatorColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            shadowColor: freezed == shadowColor
                ? _value.shadowColor
                : shadowColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            overlayColor: freezed == overlayColor
                ? _value.overlayColor
                : overlayColor // ignore: cast_nullable_to_non_nullable
                      as Color?,
            connectorWidth: freezed == connectorWidth
                ? _value.connectorWidth
                : connectorWidth // ignore: cast_nullable_to_non_nullable
                      as double?,
            indicatorSize: freezed == indicatorSize
                ? _value.indicatorSize
                : indicatorSize // ignore: cast_nullable_to_non_nullable
                      as double?,
            itemSpacing: freezed == itemSpacing
                ? _value.itemSpacing
                : itemSpacing // ignore: cast_nullable_to_non_nullable
                      as double?,
            borderRadius: freezed == borderRadius
                ? _value.borderRadius
                : borderRadius // ignore: cast_nullable_to_non_nullable
                      as double?,
            elevation: freezed == elevation
                ? _value.elevation
                : elevation // ignore: cast_nullable_to_non_nullable
                      as double?,
            padding: freezed == padding
                ? _value.padding
                : padding // ignore: cast_nullable_to_non_nullable
                      as EdgeInsetsGeometry?,
            margin: freezed == margin
                ? _value.margin
                : margin // ignore: cast_nullable_to_non_nullable
                      as EdgeInsetsGeometry?,
            constraints: freezed == constraints
                ? _value.constraints
                : constraints // ignore: cast_nullable_to_non_nullable
                      as BoxConstraints?,
            decoration: freezed == decoration
                ? _value.decoration
                : decoration // ignore: cast_nullable_to_non_nullable
                      as Decoration?,
            titleStyle: freezed == titleStyle
                ? _value.titleStyle
                : titleStyle // ignore: cast_nullable_to_non_nullable
                      as TextStyle?,
            subtitleStyle: freezed == subtitleStyle
                ? _value.subtitleStyle
                : subtitleStyle // ignore: cast_nullable_to_non_nullable
                      as TextStyle?,
            descriptionStyle: freezed == descriptionStyle
                ? _value.descriptionStyle
                : descriptionStyle // ignore: cast_nullable_to_non_nullable
                      as TextStyle?,
            timestampStyle: freezed == timestampStyle
                ? _value.timestampStyle
                : timestampStyle // ignore: cast_nullable_to_non_nullable
                      as TextStyle?,
            offset: freezed == offset
                ? _value.offset
                : offset // ignore: cast_nullable_to_non_nullable
                      as Offset?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DSTimelineStyleImplCopyWith<$Res>
    implements $DSTimelineStyleCopyWith<$Res> {
  factory _$$DSTimelineStyleImplCopyWith(
    _$DSTimelineStyleImpl value,
    $Res Function(_$DSTimelineStyleImpl) then,
  ) = __$$DSTimelineStyleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    Color? backgroundColor,
    Color? foregroundColor,
    Color? connectorColor,
    Color? indicatorColor,
    Color? shadowColor,
    Color? overlayColor,
    double? connectorWidth,
    double? indicatorSize,
    double? itemSpacing,
    double? borderRadius,
    double? elevation,
    EdgeInsetsGeometry? padding,
    EdgeInsetsGeometry? margin,
    BoxConstraints? constraints,
    Decoration? decoration,
    TextStyle? titleStyle,
    TextStyle? subtitleStyle,
    TextStyle? descriptionStyle,
    TextStyle? timestampStyle,
    Offset? offset,
  });
}

/// @nodoc
class __$$DSTimelineStyleImplCopyWithImpl<$Res>
    extends _$DSTimelineStyleCopyWithImpl<$Res, _$DSTimelineStyleImpl>
    implements _$$DSTimelineStyleImplCopyWith<$Res> {
  __$$DSTimelineStyleImplCopyWithImpl(
    _$DSTimelineStyleImpl _value,
    $Res Function(_$DSTimelineStyleImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DSTimelineStyle
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? backgroundColor = freezed,
    Object? foregroundColor = freezed,
    Object? connectorColor = freezed,
    Object? indicatorColor = freezed,
    Object? shadowColor = freezed,
    Object? overlayColor = freezed,
    Object? connectorWidth = freezed,
    Object? indicatorSize = freezed,
    Object? itemSpacing = freezed,
    Object? borderRadius = freezed,
    Object? elevation = freezed,
    Object? padding = freezed,
    Object? margin = freezed,
    Object? constraints = freezed,
    Object? decoration = freezed,
    Object? titleStyle = freezed,
    Object? subtitleStyle = freezed,
    Object? descriptionStyle = freezed,
    Object? timestampStyle = freezed,
    Object? offset = freezed,
  }) {
    return _then(
      _$DSTimelineStyleImpl(
        backgroundColor: freezed == backgroundColor
            ? _value.backgroundColor
            : backgroundColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        foregroundColor: freezed == foregroundColor
            ? _value.foregroundColor
            : foregroundColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        connectorColor: freezed == connectorColor
            ? _value.connectorColor
            : connectorColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        indicatorColor: freezed == indicatorColor
            ? _value.indicatorColor
            : indicatorColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        shadowColor: freezed == shadowColor
            ? _value.shadowColor
            : shadowColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        overlayColor: freezed == overlayColor
            ? _value.overlayColor
            : overlayColor // ignore: cast_nullable_to_non_nullable
                  as Color?,
        connectorWidth: freezed == connectorWidth
            ? _value.connectorWidth
            : connectorWidth // ignore: cast_nullable_to_non_nullable
                  as double?,
        indicatorSize: freezed == indicatorSize
            ? _value.indicatorSize
            : indicatorSize // ignore: cast_nullable_to_non_nullable
                  as double?,
        itemSpacing: freezed == itemSpacing
            ? _value.itemSpacing
            : itemSpacing // ignore: cast_nullable_to_non_nullable
                  as double?,
        borderRadius: freezed == borderRadius
            ? _value.borderRadius
            : borderRadius // ignore: cast_nullable_to_non_nullable
                  as double?,
        elevation: freezed == elevation
            ? _value.elevation
            : elevation // ignore: cast_nullable_to_non_nullable
                  as double?,
        padding: freezed == padding
            ? _value.padding
            : padding // ignore: cast_nullable_to_non_nullable
                  as EdgeInsetsGeometry?,
        margin: freezed == margin
            ? _value.margin
            : margin // ignore: cast_nullable_to_non_nullable
                  as EdgeInsetsGeometry?,
        constraints: freezed == constraints
            ? _value.constraints
            : constraints // ignore: cast_nullable_to_non_nullable
                  as BoxConstraints?,
        decoration: freezed == decoration
            ? _value.decoration
            : decoration // ignore: cast_nullable_to_non_nullable
                  as Decoration?,
        titleStyle: freezed == titleStyle
            ? _value.titleStyle
            : titleStyle // ignore: cast_nullable_to_non_nullable
                  as TextStyle?,
        subtitleStyle: freezed == subtitleStyle
            ? _value.subtitleStyle
            : subtitleStyle // ignore: cast_nullable_to_non_nullable
                  as TextStyle?,
        descriptionStyle: freezed == descriptionStyle
            ? _value.descriptionStyle
            : descriptionStyle // ignore: cast_nullable_to_non_nullable
                  as TextStyle?,
        timestampStyle: freezed == timestampStyle
            ? _value.timestampStyle
            : timestampStyle // ignore: cast_nullable_to_non_nullable
                  as TextStyle?,
        offset: freezed == offset
            ? _value.offset
            : offset // ignore: cast_nullable_to_non_nullable
                  as Offset?,
      ),
    );
  }
}

/// @nodoc

class _$DSTimelineStyleImpl extends _DSTimelineStyle {
  const _$DSTimelineStyleImpl({
    this.backgroundColor,
    this.foregroundColor,
    this.connectorColor,
    this.indicatorColor,
    this.shadowColor,
    this.overlayColor,
    this.connectorWidth,
    this.indicatorSize,
    this.itemSpacing,
    this.borderRadius,
    this.elevation,
    this.padding,
    this.margin,
    this.constraints,
    this.decoration,
    this.titleStyle,
    this.subtitleStyle,
    this.descriptionStyle,
    this.timestampStyle,
    this.offset,
  }) : super._();

  @override
  final Color? backgroundColor;
  @override
  final Color? foregroundColor;
  @override
  final Color? connectorColor;
  @override
  final Color? indicatorColor;
  @override
  final Color? shadowColor;
  @override
  final Color? overlayColor;
  @override
  final double? connectorWidth;
  @override
  final double? indicatorSize;
  @override
  final double? itemSpacing;
  @override
  final double? borderRadius;
  @override
  final double? elevation;
  @override
  final EdgeInsetsGeometry? padding;
  @override
  final EdgeInsetsGeometry? margin;
  @override
  final BoxConstraints? constraints;
  @override
  final Decoration? decoration;
  @override
  final TextStyle? titleStyle;
  @override
  final TextStyle? subtitleStyle;
  @override
  final TextStyle? descriptionStyle;
  @override
  final TextStyle? timestampStyle;
  @override
  final Offset? offset;

  @override
  String toString() {
    return 'DSTimelineStyle(backgroundColor: $backgroundColor, foregroundColor: $foregroundColor, connectorColor: $connectorColor, indicatorColor: $indicatorColor, shadowColor: $shadowColor, overlayColor: $overlayColor, connectorWidth: $connectorWidth, indicatorSize: $indicatorSize, itemSpacing: $itemSpacing, borderRadius: $borderRadius, elevation: $elevation, padding: $padding, margin: $margin, constraints: $constraints, decoration: $decoration, titleStyle: $titleStyle, subtitleStyle: $subtitleStyle, descriptionStyle: $descriptionStyle, timestampStyle: $timestampStyle, offset: $offset)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DSTimelineStyleImpl &&
            (identical(other.backgroundColor, backgroundColor) ||
                other.backgroundColor == backgroundColor) &&
            (identical(other.foregroundColor, foregroundColor) ||
                other.foregroundColor == foregroundColor) &&
            (identical(other.connectorColor, connectorColor) ||
                other.connectorColor == connectorColor) &&
            (identical(other.indicatorColor, indicatorColor) ||
                other.indicatorColor == indicatorColor) &&
            (identical(other.shadowColor, shadowColor) ||
                other.shadowColor == shadowColor) &&
            (identical(other.overlayColor, overlayColor) ||
                other.overlayColor == overlayColor) &&
            (identical(other.connectorWidth, connectorWidth) ||
                other.connectorWidth == connectorWidth) &&
            (identical(other.indicatorSize, indicatorSize) ||
                other.indicatorSize == indicatorSize) &&
            (identical(other.itemSpacing, itemSpacing) ||
                other.itemSpacing == itemSpacing) &&
            (identical(other.borderRadius, borderRadius) ||
                other.borderRadius == borderRadius) &&
            (identical(other.elevation, elevation) ||
                other.elevation == elevation) &&
            (identical(other.padding, padding) || other.padding == padding) &&
            (identical(other.margin, margin) || other.margin == margin) &&
            (identical(other.constraints, constraints) ||
                other.constraints == constraints) &&
            (identical(other.decoration, decoration) ||
                other.decoration == decoration) &&
            (identical(other.titleStyle, titleStyle) ||
                other.titleStyle == titleStyle) &&
            (identical(other.subtitleStyle, subtitleStyle) ||
                other.subtitleStyle == subtitleStyle) &&
            (identical(other.descriptionStyle, descriptionStyle) ||
                other.descriptionStyle == descriptionStyle) &&
            (identical(other.timestampStyle, timestampStyle) ||
                other.timestampStyle == timestampStyle) &&
            (identical(other.offset, offset) || other.offset == offset));
  }

  @override
  int get hashCode => Object.hashAll([
    runtimeType,
    backgroundColor,
    foregroundColor,
    connectorColor,
    indicatorColor,
    shadowColor,
    overlayColor,
    connectorWidth,
    indicatorSize,
    itemSpacing,
    borderRadius,
    elevation,
    padding,
    margin,
    constraints,
    decoration,
    titleStyle,
    subtitleStyle,
    descriptionStyle,
    timestampStyle,
    offset,
  ]);

  /// Create a copy of DSTimelineStyle
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DSTimelineStyleImplCopyWith<_$DSTimelineStyleImpl> get copyWith =>
      __$$DSTimelineStyleImplCopyWithImpl<_$DSTimelineStyleImpl>(
        this,
        _$identity,
      );
}

abstract class _DSTimelineStyle extends DSTimelineStyle {
  const factory _DSTimelineStyle({
    final Color? backgroundColor,
    final Color? foregroundColor,
    final Color? connectorColor,
    final Color? indicatorColor,
    final Color? shadowColor,
    final Color? overlayColor,
    final double? connectorWidth,
    final double? indicatorSize,
    final double? itemSpacing,
    final double? borderRadius,
    final double? elevation,
    final EdgeInsetsGeometry? padding,
    final EdgeInsetsGeometry? margin,
    final BoxConstraints? constraints,
    final Decoration? decoration,
    final TextStyle? titleStyle,
    final TextStyle? subtitleStyle,
    final TextStyle? descriptionStyle,
    final TextStyle? timestampStyle,
    final Offset? offset,
  }) = _$DSTimelineStyleImpl;
  const _DSTimelineStyle._() : super._();

  @override
  Color? get backgroundColor;
  @override
  Color? get foregroundColor;
  @override
  Color? get connectorColor;
  @override
  Color? get indicatorColor;
  @override
  Color? get shadowColor;
  @override
  Color? get overlayColor;
  @override
  double? get connectorWidth;
  @override
  double? get indicatorSize;
  @override
  double? get itemSpacing;
  @override
  double? get borderRadius;
  @override
  double? get elevation;
  @override
  EdgeInsetsGeometry? get padding;
  @override
  EdgeInsetsGeometry? get margin;
  @override
  BoxConstraints? get constraints;
  @override
  Decoration? get decoration;
  @override
  TextStyle? get titleStyle;
  @override
  TextStyle? get subtitleStyle;
  @override
  TextStyle? get descriptionStyle;
  @override
  TextStyle? get timestampStyle;
  @override
  Offset? get offset;

  /// Create a copy of DSTimelineStyle
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DSTimelineStyleImplCopyWith<_$DSTimelineStyleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DSTimelineInteraction {
  bool get enabled => throw _privateConstructorUsedError;
  bool get focusable => throw _privateConstructorUsedError;
  bool get hoverable => throw _privateConstructorUsedError;
  bool get autofocus => throw _privateConstructorUsedError;
  bool get excludeFromSemantics => throw _privateConstructorUsedError;
  FocusNode? get focusNode => throw _privateConstructorUsedError;
  ValueChanged<bool>? get onFocusChange => throw _privateConstructorUsedError;
  ValueChanged<bool>? get onHover => throw _privateConstructorUsedError;
  GestureTapCallback? get onTap => throw _privateConstructorUsedError;
  GestureLongPressCallback? get onLongPress =>
      throw _privateConstructorUsedError;
  GestureTapCallback? get onSecondaryTap => throw _privateConstructorUsedError;
  ValueChanged<int>? get onEventTap => throw _privateConstructorUsedError;
  ValueChanged<int>? get onEventLongPress => throw _privateConstructorUsedError;
  ValueChanged<int>? get onEventHover => throw _privateConstructorUsedError;
  Map<ShortcutActivator, void Function()>? get shortcuts =>
      throw _privateConstructorUsedError;

  /// Create a copy of DSTimelineInteraction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DSTimelineInteractionCopyWith<DSTimelineInteraction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DSTimelineInteractionCopyWith<$Res> {
  factory $DSTimelineInteractionCopyWith(
    DSTimelineInteraction value,
    $Res Function(DSTimelineInteraction) then,
  ) = _$DSTimelineInteractionCopyWithImpl<$Res, DSTimelineInteraction>;
  @useResult
  $Res call({
    bool enabled,
    bool focusable,
    bool hoverable,
    bool autofocus,
    bool excludeFromSemantics,
    FocusNode? focusNode,
    ValueChanged<bool>? onFocusChange,
    ValueChanged<bool>? onHover,
    GestureTapCallback? onTap,
    GestureLongPressCallback? onLongPress,
    GestureTapCallback? onSecondaryTap,
    ValueChanged<int>? onEventTap,
    ValueChanged<int>? onEventLongPress,
    ValueChanged<int>? onEventHover,
    Map<ShortcutActivator, void Function()>? shortcuts,
  });
}

/// @nodoc
class _$DSTimelineInteractionCopyWithImpl<
  $Res,
  $Val extends DSTimelineInteraction
>
    implements $DSTimelineInteractionCopyWith<$Res> {
  _$DSTimelineInteractionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DSTimelineInteraction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? focusable = null,
    Object? hoverable = null,
    Object? autofocus = null,
    Object? excludeFromSemantics = null,
    Object? focusNode = freezed,
    Object? onFocusChange = freezed,
    Object? onHover = freezed,
    Object? onTap = freezed,
    Object? onLongPress = freezed,
    Object? onSecondaryTap = freezed,
    Object? onEventTap = freezed,
    Object? onEventLongPress = freezed,
    Object? onEventHover = freezed,
    Object? shortcuts = freezed,
  }) {
    return _then(
      _value.copyWith(
            enabled: null == enabled
                ? _value.enabled
                : enabled // ignore: cast_nullable_to_non_nullable
                      as bool,
            focusable: null == focusable
                ? _value.focusable
                : focusable // ignore: cast_nullable_to_non_nullable
                      as bool,
            hoverable: null == hoverable
                ? _value.hoverable
                : hoverable // ignore: cast_nullable_to_non_nullable
                      as bool,
            autofocus: null == autofocus
                ? _value.autofocus
                : autofocus // ignore: cast_nullable_to_non_nullable
                      as bool,
            excludeFromSemantics: null == excludeFromSemantics
                ? _value.excludeFromSemantics
                : excludeFromSemantics // ignore: cast_nullable_to_non_nullable
                      as bool,
            focusNode: freezed == focusNode
                ? _value.focusNode
                : focusNode // ignore: cast_nullable_to_non_nullable
                      as FocusNode?,
            onFocusChange: freezed == onFocusChange
                ? _value.onFocusChange
                : onFocusChange // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<bool>?,
            onHover: freezed == onHover
                ? _value.onHover
                : onHover // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<bool>?,
            onTap: freezed == onTap
                ? _value.onTap
                : onTap // ignore: cast_nullable_to_non_nullable
                      as GestureTapCallback?,
            onLongPress: freezed == onLongPress
                ? _value.onLongPress
                : onLongPress // ignore: cast_nullable_to_non_nullable
                      as GestureLongPressCallback?,
            onSecondaryTap: freezed == onSecondaryTap
                ? _value.onSecondaryTap
                : onSecondaryTap // ignore: cast_nullable_to_non_nullable
                      as GestureTapCallback?,
            onEventTap: freezed == onEventTap
                ? _value.onEventTap
                : onEventTap // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<int>?,
            onEventLongPress: freezed == onEventLongPress
                ? _value.onEventLongPress
                : onEventLongPress // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<int>?,
            onEventHover: freezed == onEventHover
                ? _value.onEventHover
                : onEventHover // ignore: cast_nullable_to_non_nullable
                      as ValueChanged<int>?,
            shortcuts: freezed == shortcuts
                ? _value.shortcuts
                : shortcuts // ignore: cast_nullable_to_non_nullable
                      as Map<ShortcutActivator, void Function()>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DSTimelineInteractionImplCopyWith<$Res>
    implements $DSTimelineInteractionCopyWith<$Res> {
  factory _$$DSTimelineInteractionImplCopyWith(
    _$DSTimelineInteractionImpl value,
    $Res Function(_$DSTimelineInteractionImpl) then,
  ) = __$$DSTimelineInteractionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    bool enabled,
    bool focusable,
    bool hoverable,
    bool autofocus,
    bool excludeFromSemantics,
    FocusNode? focusNode,
    ValueChanged<bool>? onFocusChange,
    ValueChanged<bool>? onHover,
    GestureTapCallback? onTap,
    GestureLongPressCallback? onLongPress,
    GestureTapCallback? onSecondaryTap,
    ValueChanged<int>? onEventTap,
    ValueChanged<int>? onEventLongPress,
    ValueChanged<int>? onEventHover,
    Map<ShortcutActivator, void Function()>? shortcuts,
  });
}

/// @nodoc
class __$$DSTimelineInteractionImplCopyWithImpl<$Res>
    extends
        _$DSTimelineInteractionCopyWithImpl<$Res, _$DSTimelineInteractionImpl>
    implements _$$DSTimelineInteractionImplCopyWith<$Res> {
  __$$DSTimelineInteractionImplCopyWithImpl(
    _$DSTimelineInteractionImpl _value,
    $Res Function(_$DSTimelineInteractionImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DSTimelineInteraction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? focusable = null,
    Object? hoverable = null,
    Object? autofocus = null,
    Object? excludeFromSemantics = null,
    Object? focusNode = freezed,
    Object? onFocusChange = freezed,
    Object? onHover = freezed,
    Object? onTap = freezed,
    Object? onLongPress = freezed,
    Object? onSecondaryTap = freezed,
    Object? onEventTap = freezed,
    Object? onEventLongPress = freezed,
    Object? onEventHover = freezed,
    Object? shortcuts = freezed,
  }) {
    return _then(
      _$DSTimelineInteractionImpl(
        enabled: null == enabled
            ? _value.enabled
            : enabled // ignore: cast_nullable_to_non_nullable
                  as bool,
        focusable: null == focusable
            ? _value.focusable
            : focusable // ignore: cast_nullable_to_non_nullable
                  as bool,
        hoverable: null == hoverable
            ? _value.hoverable
            : hoverable // ignore: cast_nullable_to_non_nullable
                  as bool,
        autofocus: null == autofocus
            ? _value.autofocus
            : autofocus // ignore: cast_nullable_to_non_nullable
                  as bool,
        excludeFromSemantics: null == excludeFromSemantics
            ? _value.excludeFromSemantics
            : excludeFromSemantics // ignore: cast_nullable_to_non_nullable
                  as bool,
        focusNode: freezed == focusNode
            ? _value.focusNode
            : focusNode // ignore: cast_nullable_to_non_nullable
                  as FocusNode?,
        onFocusChange: freezed == onFocusChange
            ? _value.onFocusChange
            : onFocusChange // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<bool>?,
        onHover: freezed == onHover
            ? _value.onHover
            : onHover // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<bool>?,
        onTap: freezed == onTap
            ? _value.onTap
            : onTap // ignore: cast_nullable_to_non_nullable
                  as GestureTapCallback?,
        onLongPress: freezed == onLongPress
            ? _value.onLongPress
            : onLongPress // ignore: cast_nullable_to_non_nullable
                  as GestureLongPressCallback?,
        onSecondaryTap: freezed == onSecondaryTap
            ? _value.onSecondaryTap
            : onSecondaryTap // ignore: cast_nullable_to_non_nullable
                  as GestureTapCallback?,
        onEventTap: freezed == onEventTap
            ? _value.onEventTap
            : onEventTap // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<int>?,
        onEventLongPress: freezed == onEventLongPress
            ? _value.onEventLongPress
            : onEventLongPress // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<int>?,
        onEventHover: freezed == onEventHover
            ? _value.onEventHover
            : onEventHover // ignore: cast_nullable_to_non_nullable
                  as ValueChanged<int>?,
        shortcuts: freezed == shortcuts
            ? _value._shortcuts
            : shortcuts // ignore: cast_nullable_to_non_nullable
                  as Map<ShortcutActivator, void Function()>?,
      ),
    );
  }
}

/// @nodoc

class _$DSTimelineInteractionImpl implements _DSTimelineInteraction {
  const _$DSTimelineInteractionImpl({
    this.enabled = true,
    this.focusable = true,
    this.hoverable = true,
    this.autofocus = false,
    this.excludeFromSemantics = false,
    this.focusNode,
    this.onFocusChange,
    this.onHover,
    this.onTap,
    this.onLongPress,
    this.onSecondaryTap,
    this.onEventTap,
    this.onEventLongPress,
    this.onEventHover,
    final Map<ShortcutActivator, void Function()>? shortcuts,
  }) : _shortcuts = shortcuts;

  @override
  @JsonKey()
  final bool enabled;
  @override
  @JsonKey()
  final bool focusable;
  @override
  @JsonKey()
  final bool hoverable;
  @override
  @JsonKey()
  final bool autofocus;
  @override
  @JsonKey()
  final bool excludeFromSemantics;
  @override
  final FocusNode? focusNode;
  @override
  final ValueChanged<bool>? onFocusChange;
  @override
  final ValueChanged<bool>? onHover;
  @override
  final GestureTapCallback? onTap;
  @override
  final GestureLongPressCallback? onLongPress;
  @override
  final GestureTapCallback? onSecondaryTap;
  @override
  final ValueChanged<int>? onEventTap;
  @override
  final ValueChanged<int>? onEventLongPress;
  @override
  final ValueChanged<int>? onEventHover;
  final Map<ShortcutActivator, void Function()>? _shortcuts;
  @override
  Map<ShortcutActivator, void Function()>? get shortcuts {
    final value = _shortcuts;
    if (value == null) return null;
    if (_shortcuts is EqualUnmodifiableMapView) return _shortcuts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'DSTimelineInteraction(enabled: $enabled, focusable: $focusable, hoverable: $hoverable, autofocus: $autofocus, excludeFromSemantics: $excludeFromSemantics, focusNode: $focusNode, onFocusChange: $onFocusChange, onHover: $onHover, onTap: $onTap, onLongPress: $onLongPress, onSecondaryTap: $onSecondaryTap, onEventTap: $onEventTap, onEventLongPress: $onEventLongPress, onEventHover: $onEventHover, shortcuts: $shortcuts)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DSTimelineInteractionImpl &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.focusable, focusable) ||
                other.focusable == focusable) &&
            (identical(other.hoverable, hoverable) ||
                other.hoverable == hoverable) &&
            (identical(other.autofocus, autofocus) ||
                other.autofocus == autofocus) &&
            (identical(other.excludeFromSemantics, excludeFromSemantics) ||
                other.excludeFromSemantics == excludeFromSemantics) &&
            (identical(other.focusNode, focusNode) ||
                other.focusNode == focusNode) &&
            (identical(other.onFocusChange, onFocusChange) ||
                other.onFocusChange == onFocusChange) &&
            (identical(other.onHover, onHover) || other.onHover == onHover) &&
            (identical(other.onTap, onTap) || other.onTap == onTap) &&
            (identical(other.onLongPress, onLongPress) ||
                other.onLongPress == onLongPress) &&
            (identical(other.onSecondaryTap, onSecondaryTap) ||
                other.onSecondaryTap == onSecondaryTap) &&
            (identical(other.onEventTap, onEventTap) ||
                other.onEventTap == onEventTap) &&
            (identical(other.onEventLongPress, onEventLongPress) ||
                other.onEventLongPress == onEventLongPress) &&
            (identical(other.onEventHover, onEventHover) ||
                other.onEventHover == onEventHover) &&
            const DeepCollectionEquality().equals(
              other._shortcuts,
              _shortcuts,
            ));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    enabled,
    focusable,
    hoverable,
    autofocus,
    excludeFromSemantics,
    focusNode,
    onFocusChange,
    onHover,
    onTap,
    onLongPress,
    onSecondaryTap,
    onEventTap,
    onEventLongPress,
    onEventHover,
    const DeepCollectionEquality().hash(_shortcuts),
  );

  /// Create a copy of DSTimelineInteraction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DSTimelineInteractionImplCopyWith<_$DSTimelineInteractionImpl>
  get copyWith =>
      __$$DSTimelineInteractionImplCopyWithImpl<_$DSTimelineInteractionImpl>(
        this,
        _$identity,
      );
}

abstract class _DSTimelineInteraction implements DSTimelineInteraction {
  const factory _DSTimelineInteraction({
    final bool enabled,
    final bool focusable,
    final bool hoverable,
    final bool autofocus,
    final bool excludeFromSemantics,
    final FocusNode? focusNode,
    final ValueChanged<bool>? onFocusChange,
    final ValueChanged<bool>? onHover,
    final GestureTapCallback? onTap,
    final GestureLongPressCallback? onLongPress,
    final GestureTapCallback? onSecondaryTap,
    final ValueChanged<int>? onEventTap,
    final ValueChanged<int>? onEventLongPress,
    final ValueChanged<int>? onEventHover,
    final Map<ShortcutActivator, void Function()>? shortcuts,
  }) = _$DSTimelineInteractionImpl;

  @override
  bool get enabled;
  @override
  bool get focusable;
  @override
  bool get hoverable;
  @override
  bool get autofocus;
  @override
  bool get excludeFromSemantics;
  @override
  FocusNode? get focusNode;
  @override
  ValueChanged<bool>? get onFocusChange;
  @override
  ValueChanged<bool>? get onHover;
  @override
  GestureTapCallback? get onTap;
  @override
  GestureLongPressCallback? get onLongPress;
  @override
  GestureTapCallback? get onSecondaryTap;
  @override
  ValueChanged<int>? get onEventTap;
  @override
  ValueChanged<int>? get onEventLongPress;
  @override
  ValueChanged<int>? get onEventHover;
  @override
  Map<ShortcutActivator, void Function()>? get shortcuts;

  /// Create a copy of DSTimelineInteraction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DSTimelineInteractionImplCopyWith<_$DSTimelineInteractionImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DSTimelineAccessibility {
  String? get semanticLabel => throw _privateConstructorUsedError;
  String? get tooltip => throw _privateConstructorUsedError;
  bool? get excludeSemantics => throw _privateConstructorUsedError;
  bool? get obscureText => throw _privateConstructorUsedError;
  String? get onTapHint => throw _privateConstructorUsedError;
  String? get onLongPressHint => throw _privateConstructorUsedError;
  bool get sortKey => throw _privateConstructorUsedError;
  bool get liveRegion => throw _privateConstructorUsedError;
  bool get focusable => throw _privateConstructorUsedError;
  bool get button => throw _privateConstructorUsedError;
  bool get list => throw _privateConstructorUsedError;
  bool get readOnly => throw _privateConstructorUsedError;

  /// Create a copy of DSTimelineAccessibility
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DSTimelineAccessibilityCopyWith<DSTimelineAccessibility> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DSTimelineAccessibilityCopyWith<$Res> {
  factory $DSTimelineAccessibilityCopyWith(
    DSTimelineAccessibility value,
    $Res Function(DSTimelineAccessibility) then,
  ) = _$DSTimelineAccessibilityCopyWithImpl<$Res, DSTimelineAccessibility>;
  @useResult
  $Res call({
    String? semanticLabel,
    String? tooltip,
    bool? excludeSemantics,
    bool? obscureText,
    String? onTapHint,
    String? onLongPressHint,
    bool sortKey,
    bool liveRegion,
    bool focusable,
    bool button,
    bool list,
    bool readOnly,
  });
}

/// @nodoc
class _$DSTimelineAccessibilityCopyWithImpl<
  $Res,
  $Val extends DSTimelineAccessibility
>
    implements $DSTimelineAccessibilityCopyWith<$Res> {
  _$DSTimelineAccessibilityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DSTimelineAccessibility
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? semanticLabel = freezed,
    Object? tooltip = freezed,
    Object? excludeSemantics = freezed,
    Object? obscureText = freezed,
    Object? onTapHint = freezed,
    Object? onLongPressHint = freezed,
    Object? sortKey = null,
    Object? liveRegion = null,
    Object? focusable = null,
    Object? button = null,
    Object? list = null,
    Object? readOnly = null,
  }) {
    return _then(
      _value.copyWith(
            semanticLabel: freezed == semanticLabel
                ? _value.semanticLabel
                : semanticLabel // ignore: cast_nullable_to_non_nullable
                      as String?,
            tooltip: freezed == tooltip
                ? _value.tooltip
                : tooltip // ignore: cast_nullable_to_non_nullable
                      as String?,
            excludeSemantics: freezed == excludeSemantics
                ? _value.excludeSemantics
                : excludeSemantics // ignore: cast_nullable_to_non_nullable
                      as bool?,
            obscureText: freezed == obscureText
                ? _value.obscureText
                : obscureText // ignore: cast_nullable_to_non_nullable
                      as bool?,
            onTapHint: freezed == onTapHint
                ? _value.onTapHint
                : onTapHint // ignore: cast_nullable_to_non_nullable
                      as String?,
            onLongPressHint: freezed == onLongPressHint
                ? _value.onLongPressHint
                : onLongPressHint // ignore: cast_nullable_to_non_nullable
                      as String?,
            sortKey: null == sortKey
                ? _value.sortKey
                : sortKey // ignore: cast_nullable_to_non_nullable
                      as bool,
            liveRegion: null == liveRegion
                ? _value.liveRegion
                : liveRegion // ignore: cast_nullable_to_non_nullable
                      as bool,
            focusable: null == focusable
                ? _value.focusable
                : focusable // ignore: cast_nullable_to_non_nullable
                      as bool,
            button: null == button
                ? _value.button
                : button // ignore: cast_nullable_to_non_nullable
                      as bool,
            list: null == list
                ? _value.list
                : list // ignore: cast_nullable_to_non_nullable
                      as bool,
            readOnly: null == readOnly
                ? _value.readOnly
                : readOnly // ignore: cast_nullable_to_non_nullable
                      as bool,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DSTimelineAccessibilityImplCopyWith<$Res>
    implements $DSTimelineAccessibilityCopyWith<$Res> {
  factory _$$DSTimelineAccessibilityImplCopyWith(
    _$DSTimelineAccessibilityImpl value,
    $Res Function(_$DSTimelineAccessibilityImpl) then,
  ) = __$$DSTimelineAccessibilityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String? semanticLabel,
    String? tooltip,
    bool? excludeSemantics,
    bool? obscureText,
    String? onTapHint,
    String? onLongPressHint,
    bool sortKey,
    bool liveRegion,
    bool focusable,
    bool button,
    bool list,
    bool readOnly,
  });
}

/// @nodoc
class __$$DSTimelineAccessibilityImplCopyWithImpl<$Res>
    extends
        _$DSTimelineAccessibilityCopyWithImpl<
          $Res,
          _$DSTimelineAccessibilityImpl
        >
    implements _$$DSTimelineAccessibilityImplCopyWith<$Res> {
  __$$DSTimelineAccessibilityImplCopyWithImpl(
    _$DSTimelineAccessibilityImpl _value,
    $Res Function(_$DSTimelineAccessibilityImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DSTimelineAccessibility
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? semanticLabel = freezed,
    Object? tooltip = freezed,
    Object? excludeSemantics = freezed,
    Object? obscureText = freezed,
    Object? onTapHint = freezed,
    Object? onLongPressHint = freezed,
    Object? sortKey = null,
    Object? liveRegion = null,
    Object? focusable = null,
    Object? button = null,
    Object? list = null,
    Object? readOnly = null,
  }) {
    return _then(
      _$DSTimelineAccessibilityImpl(
        semanticLabel: freezed == semanticLabel
            ? _value.semanticLabel
            : semanticLabel // ignore: cast_nullable_to_non_nullable
                  as String?,
        tooltip: freezed == tooltip
            ? _value.tooltip
            : tooltip // ignore: cast_nullable_to_non_nullable
                  as String?,
        excludeSemantics: freezed == excludeSemantics
            ? _value.excludeSemantics
            : excludeSemantics // ignore: cast_nullable_to_non_nullable
                  as bool?,
        obscureText: freezed == obscureText
            ? _value.obscureText
            : obscureText // ignore: cast_nullable_to_non_nullable
                  as bool?,
        onTapHint: freezed == onTapHint
            ? _value.onTapHint
            : onTapHint // ignore: cast_nullable_to_non_nullable
                  as String?,
        onLongPressHint: freezed == onLongPressHint
            ? _value.onLongPressHint
            : onLongPressHint // ignore: cast_nullable_to_non_nullable
                  as String?,
        sortKey: null == sortKey
            ? _value.sortKey
            : sortKey // ignore: cast_nullable_to_non_nullable
                  as bool,
        liveRegion: null == liveRegion
            ? _value.liveRegion
            : liveRegion // ignore: cast_nullable_to_non_nullable
                  as bool,
        focusable: null == focusable
            ? _value.focusable
            : focusable // ignore: cast_nullable_to_non_nullable
                  as bool,
        button: null == button
            ? _value.button
            : button // ignore: cast_nullable_to_non_nullable
                  as bool,
        list: null == list
            ? _value.list
            : list // ignore: cast_nullable_to_non_nullable
                  as bool,
        readOnly: null == readOnly
            ? _value.readOnly
            : readOnly // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }
}

/// @nodoc

class _$DSTimelineAccessibilityImpl implements _DSTimelineAccessibility {
  const _$DSTimelineAccessibilityImpl({
    this.semanticLabel,
    this.tooltip,
    this.excludeSemantics,
    this.obscureText,
    this.onTapHint,
    this.onLongPressHint,
    this.sortKey = false,
    this.liveRegion = false,
    this.focusable = false,
    this.button = false,
    this.list = false,
    this.readOnly = false,
  });

  @override
  final String? semanticLabel;
  @override
  final String? tooltip;
  @override
  final bool? excludeSemantics;
  @override
  final bool? obscureText;
  @override
  final String? onTapHint;
  @override
  final String? onLongPressHint;
  @override
  @JsonKey()
  final bool sortKey;
  @override
  @JsonKey()
  final bool liveRegion;
  @override
  @JsonKey()
  final bool focusable;
  @override
  @JsonKey()
  final bool button;
  @override
  @JsonKey()
  final bool list;
  @override
  @JsonKey()
  final bool readOnly;

  @override
  String toString() {
    return 'DSTimelineAccessibility(semanticLabel: $semanticLabel, tooltip: $tooltip, excludeSemantics: $excludeSemantics, obscureText: $obscureText, onTapHint: $onTapHint, onLongPressHint: $onLongPressHint, sortKey: $sortKey, liveRegion: $liveRegion, focusable: $focusable, button: $button, list: $list, readOnly: $readOnly)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DSTimelineAccessibilityImpl &&
            (identical(other.semanticLabel, semanticLabel) ||
                other.semanticLabel == semanticLabel) &&
            (identical(other.tooltip, tooltip) || other.tooltip == tooltip) &&
            (identical(other.excludeSemantics, excludeSemantics) ||
                other.excludeSemantics == excludeSemantics) &&
            (identical(other.obscureText, obscureText) ||
                other.obscureText == obscureText) &&
            (identical(other.onTapHint, onTapHint) ||
                other.onTapHint == onTapHint) &&
            (identical(other.onLongPressHint, onLongPressHint) ||
                other.onLongPressHint == onLongPressHint) &&
            (identical(other.sortKey, sortKey) || other.sortKey == sortKey) &&
            (identical(other.liveRegion, liveRegion) ||
                other.liveRegion == liveRegion) &&
            (identical(other.focusable, focusable) ||
                other.focusable == focusable) &&
            (identical(other.button, button) || other.button == button) &&
            (identical(other.list, list) || other.list == list) &&
            (identical(other.readOnly, readOnly) ||
                other.readOnly == readOnly));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    semanticLabel,
    tooltip,
    excludeSemantics,
    obscureText,
    onTapHint,
    onLongPressHint,
    sortKey,
    liveRegion,
    focusable,
    button,
    list,
    readOnly,
  );

  /// Create a copy of DSTimelineAccessibility
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DSTimelineAccessibilityImplCopyWith<_$DSTimelineAccessibilityImpl>
  get copyWith =>
      __$$DSTimelineAccessibilityImplCopyWithImpl<
        _$DSTimelineAccessibilityImpl
      >(this, _$identity);
}

abstract class _DSTimelineAccessibility implements DSTimelineAccessibility {
  const factory _DSTimelineAccessibility({
    final String? semanticLabel,
    final String? tooltip,
    final bool? excludeSemantics,
    final bool? obscureText,
    final String? onTapHint,
    final String? onLongPressHint,
    final bool sortKey,
    final bool liveRegion,
    final bool focusable,
    final bool button,
    final bool list,
    final bool readOnly,
  }) = _$DSTimelineAccessibilityImpl;

  @override
  String? get semanticLabel;
  @override
  String? get tooltip;
  @override
  bool? get excludeSemantics;
  @override
  bool? get obscureText;
  @override
  String? get onTapHint;
  @override
  String? get onLongPressHint;
  @override
  bool get sortKey;
  @override
  bool get liveRegion;
  @override
  bool get focusable;
  @override
  bool get button;
  @override
  bool get list;
  @override
  bool get readOnly;

  /// Create a copy of DSTimelineAccessibility
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DSTimelineAccessibilityImplCopyWith<_$DSTimelineAccessibilityImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DSTimelineAnimation {
  Duration get duration => throw _privateConstructorUsedError;
  Curve get curve => throw _privateConstructorUsedError;
  bool get enabled => throw _privateConstructorUsedError;
  DSTimelineAnimationType get type => throw _privateConstructorUsedError;
  Duration? get delay => throw _privateConstructorUsedError;
  VoidCallback? get onAnimationComplete => throw _privateConstructorUsedError;
  bool get staggered => throw _privateConstructorUsedError;
  Duration get staggerDelay => throw _privateConstructorUsedError;
  bool get autoPlay => throw _privateConstructorUsedError;

  /// Create a copy of DSTimelineAnimation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DSTimelineAnimationCopyWith<DSTimelineAnimation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DSTimelineAnimationCopyWith<$Res> {
  factory $DSTimelineAnimationCopyWith(
    DSTimelineAnimation value,
    $Res Function(DSTimelineAnimation) then,
  ) = _$DSTimelineAnimationCopyWithImpl<$Res, DSTimelineAnimation>;
  @useResult
  $Res call({
    Duration duration,
    Curve curve,
    bool enabled,
    DSTimelineAnimationType type,
    Duration? delay,
    VoidCallback? onAnimationComplete,
    bool staggered,
    Duration staggerDelay,
    bool autoPlay,
  });
}

/// @nodoc
class _$DSTimelineAnimationCopyWithImpl<$Res, $Val extends DSTimelineAnimation>
    implements $DSTimelineAnimationCopyWith<$Res> {
  _$DSTimelineAnimationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DSTimelineAnimation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? duration = null,
    Object? curve = null,
    Object? enabled = null,
    Object? type = null,
    Object? delay = freezed,
    Object? onAnimationComplete = freezed,
    Object? staggered = null,
    Object? staggerDelay = null,
    Object? autoPlay = null,
  }) {
    return _then(
      _value.copyWith(
            duration: null == duration
                ? _value.duration
                : duration // ignore: cast_nullable_to_non_nullable
                      as Duration,
            curve: null == curve
                ? _value.curve
                : curve // ignore: cast_nullable_to_non_nullable
                      as Curve,
            enabled: null == enabled
                ? _value.enabled
                : enabled // ignore: cast_nullable_to_non_nullable
                      as bool,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as DSTimelineAnimationType,
            delay: freezed == delay
                ? _value.delay
                : delay // ignore: cast_nullable_to_non_nullable
                      as Duration?,
            onAnimationComplete: freezed == onAnimationComplete
                ? _value.onAnimationComplete
                : onAnimationComplete // ignore: cast_nullable_to_non_nullable
                      as VoidCallback?,
            staggered: null == staggered
                ? _value.staggered
                : staggered // ignore: cast_nullable_to_non_nullable
                      as bool,
            staggerDelay: null == staggerDelay
                ? _value.staggerDelay
                : staggerDelay // ignore: cast_nullable_to_non_nullable
                      as Duration,
            autoPlay: null == autoPlay
                ? _value.autoPlay
                : autoPlay // ignore: cast_nullable_to_non_nullable
                      as bool,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DSTimelineAnimationImplCopyWith<$Res>
    implements $DSTimelineAnimationCopyWith<$Res> {
  factory _$$DSTimelineAnimationImplCopyWith(
    _$DSTimelineAnimationImpl value,
    $Res Function(_$DSTimelineAnimationImpl) then,
  ) = __$$DSTimelineAnimationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    Duration duration,
    Curve curve,
    bool enabled,
    DSTimelineAnimationType type,
    Duration? delay,
    VoidCallback? onAnimationComplete,
    bool staggered,
    Duration staggerDelay,
    bool autoPlay,
  });
}

/// @nodoc
class __$$DSTimelineAnimationImplCopyWithImpl<$Res>
    extends _$DSTimelineAnimationCopyWithImpl<$Res, _$DSTimelineAnimationImpl>
    implements _$$DSTimelineAnimationImplCopyWith<$Res> {
  __$$DSTimelineAnimationImplCopyWithImpl(
    _$DSTimelineAnimationImpl _value,
    $Res Function(_$DSTimelineAnimationImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DSTimelineAnimation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? duration = null,
    Object? curve = null,
    Object? enabled = null,
    Object? type = null,
    Object? delay = freezed,
    Object? onAnimationComplete = freezed,
    Object? staggered = null,
    Object? staggerDelay = null,
    Object? autoPlay = null,
  }) {
    return _then(
      _$DSTimelineAnimationImpl(
        duration: null == duration
            ? _value.duration
            : duration // ignore: cast_nullable_to_non_nullable
                  as Duration,
        curve: null == curve
            ? _value.curve
            : curve // ignore: cast_nullable_to_non_nullable
                  as Curve,
        enabled: null == enabled
            ? _value.enabled
            : enabled // ignore: cast_nullable_to_non_nullable
                  as bool,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as DSTimelineAnimationType,
        delay: freezed == delay
            ? _value.delay
            : delay // ignore: cast_nullable_to_non_nullable
                  as Duration?,
        onAnimationComplete: freezed == onAnimationComplete
            ? _value.onAnimationComplete
            : onAnimationComplete // ignore: cast_nullable_to_non_nullable
                  as VoidCallback?,
        staggered: null == staggered
            ? _value.staggered
            : staggered // ignore: cast_nullable_to_non_nullable
                  as bool,
        staggerDelay: null == staggerDelay
            ? _value.staggerDelay
            : staggerDelay // ignore: cast_nullable_to_non_nullable
                  as Duration,
        autoPlay: null == autoPlay
            ? _value.autoPlay
            : autoPlay // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }
}

/// @nodoc

class _$DSTimelineAnimationImpl implements _DSTimelineAnimation {
  const _$DSTimelineAnimationImpl({
    this.duration = const Duration(milliseconds: 200),
    this.curve = Curves.easeInOut,
    this.enabled = false,
    this.type = DSTimelineAnimationType.fade,
    this.delay,
    this.onAnimationComplete,
    this.staggered = false,
    this.staggerDelay = const Duration(milliseconds: 100),
    this.autoPlay = false,
  });

  @override
  @JsonKey()
  final Duration duration;
  @override
  @JsonKey()
  final Curve curve;
  @override
  @JsonKey()
  final bool enabled;
  @override
  @JsonKey()
  final DSTimelineAnimationType type;
  @override
  final Duration? delay;
  @override
  final VoidCallback? onAnimationComplete;
  @override
  @JsonKey()
  final bool staggered;
  @override
  @JsonKey()
  final Duration staggerDelay;
  @override
  @JsonKey()
  final bool autoPlay;

  @override
  String toString() {
    return 'DSTimelineAnimation(duration: $duration, curve: $curve, enabled: $enabled, type: $type, delay: $delay, onAnimationComplete: $onAnimationComplete, staggered: $staggered, staggerDelay: $staggerDelay, autoPlay: $autoPlay)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DSTimelineAnimationImpl &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.curve, curve) || other.curve == curve) &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.delay, delay) || other.delay == delay) &&
            (identical(other.onAnimationComplete, onAnimationComplete) ||
                other.onAnimationComplete == onAnimationComplete) &&
            (identical(other.staggered, staggered) ||
                other.staggered == staggered) &&
            (identical(other.staggerDelay, staggerDelay) ||
                other.staggerDelay == staggerDelay) &&
            (identical(other.autoPlay, autoPlay) ||
                other.autoPlay == autoPlay));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    duration,
    curve,
    enabled,
    type,
    delay,
    onAnimationComplete,
    staggered,
    staggerDelay,
    autoPlay,
  );

  /// Create a copy of DSTimelineAnimation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DSTimelineAnimationImplCopyWith<_$DSTimelineAnimationImpl> get copyWith =>
      __$$DSTimelineAnimationImplCopyWithImpl<_$DSTimelineAnimationImpl>(
        this,
        _$identity,
      );
}

abstract class _DSTimelineAnimation implements DSTimelineAnimation {
  const factory _DSTimelineAnimation({
    final Duration duration,
    final Curve curve,
    final bool enabled,
    final DSTimelineAnimationType type,
    final Duration? delay,
    final VoidCallback? onAnimationComplete,
    final bool staggered,
    final Duration staggerDelay,
    final bool autoPlay,
  }) = _$DSTimelineAnimationImpl;

  @override
  Duration get duration;
  @override
  Curve get curve;
  @override
  bool get enabled;
  @override
  DSTimelineAnimationType get type;
  @override
  Duration? get delay;
  @override
  VoidCallback? get onAnimationComplete;
  @override
  bool get staggered;
  @override
  Duration get staggerDelay;
  @override
  bool get autoPlay;

  /// Create a copy of DSTimelineAnimation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DSTimelineAnimationImplCopyWith<_$DSTimelineAnimationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
